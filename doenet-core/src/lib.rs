pub mod state_variables;
pub mod component;

pub mod state;
pub mod parse_json;
pub mod utils;
pub mod base_definitions;
pub mod math_expression;

use base_definitions::{PROP_INDEX_SV, prop_index_determine_value, get_children_of_type};
use lazy_static::lazy_static;
use parse_json::{DoenetMLError, DoenetMLWarning, MLComponent, RangeInDoenetML};
use state::StateForStateVar;
use std::collections::HashMap;
use std::fmt::{Debug, Display};
use std::hash::Hash;

use state::{State, EssentialStateVar};
use component::*;
use state_variables::*;

use crate::math_expression::MathExpression;
use crate::utils::{log_json, log_debug, log};
use serde::Serialize;


/// A static DoenetCore is created from parsed DoenetML at the beginning.
/// While `component_states` and `essential_data` can update using
/// internal mutability (the RefCell), the over-arching HashMaps are static.
#[derive(Debug)]
pub struct DoenetCore {
    /// The component tree has almost the same structure as the tree of elements
    /// typed into DoenetML, except macros are converted into their own components.
    pub component_nodes: HashMap<ComponentName, ComponentNode>,

    /// State variables
    pub component_states: HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>,

    /// This should always be the name of a <document> component
    pub root_component_name: ComponentName,

    /// **The Dependency Graph**
    /// A DAG whose vertices are the state variables and attributes
    /// of every component, and whose endpoint vertices are essential data.
    ///
    /// Used for
    /// - producing values when determining a state variable
    /// - tracking when a change affects other state variables
    pub dependencies: HashMap<DependencyKey, Vec<Dependency>>,

    /// This determines which components a Collection includes
    pub collection_members: HashMap<ComponentName, Vec<CollectionMembers>>,

    /// Endpoints of the dependency graph.
    /// Every update instruction will lead to these.
    pub essential_data: HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
}



// ==== Five levels: ComponentNode to RenderedComponent ====

/// Created by the DoenetML: an xml component or a macro
#[derive(Debug, Clone)]
pub struct ComponentNode {

    pub name: ComponentName,
    pub parent: Option<ComponentName>,
    pub children: Vec<ComponentChild>,

    pub copy_source: Option<CopySource>,
    pub static_attributes: HashMap<AttributeName, String>,

    pub definition: &'static ComponentDefinition,
}

/// Refers to a ComponentNode
/// A ComponentName is not static because it cannot be known at compile time.
pub type ComponentName = String;

/// An instance is specified to refer to an instance of the component,
/// in case it is inside <map> components.
/// Component states are associated with this type.
#[derive(Debug, Clone)]
pub struct ComponentInstance<'a> {
    node: &'a ComponentNode,
    instance: Instance,
}

/// Components inside a <map> are assigned this vector.
/// The length is the number of maps a component is inside,
/// and each index selects the map instance a component belongs to.
/// When a component is not inside a map (most of the time) this is empty.
/// Note: indexing starts at 1
pub type Instance = Vec<usize>;

/// A superset of ComponentInstance that includes members generated by a batch
/// For example, a <sequence> generates a set of <number> that can be refered to as
/// a batch member of the sequence.
#[derive(Serialize, Clone, Debug, PartialEq, Eq)]
pub enum ComponentGenerated<'a> {
    Node(ComponentInstance<'a>),

    /// When BatchName is None, this refers to the replacement components batch.
    BatchMember(ComponentInstance<'a>, Option<BatchName>, usize),
}
use ComponentGenerated::*;

/// The same as a ComponentGenerated components, with the addition of collections
/// that duplicate ComponentGenerated components, as specified by the CollectionMembers.
#[derive(Serialize, Clone, Debug, PartialEq, Eq)]
pub enum ComponentRef<'a> {
    Component(ComponentGenerated<'a>),
    CollectionMember(ComponentInstance<'a>, usize), // refers to an existing ComponentGenerated
}

/// A superset of ComponentRefs that includes children of duplicates:
/// copies and collection members.
/// This corresponds to one component in the component tree sent to the renderer.
#[derive(Debug)]
struct RenderedComponent<'a> {
    component_ref: ComponentRef<'a>,
    child_of_copy: Option<ComponentRef<'a>>,
}



/// Dependencies keyed by:
/// 1. the name of the component
/// 2. the name of a state variable slice
///    which allows for two kinds of dependencies:
///      - direct dependency: when a single state var depends on something
///      - indirect dependency: when a group depends on something,
///        and members of the group inherit the dependency.
///        The motivation for indirect dependencies is that
///        the size of groups can change (e.g. an array changes size).
///        To keep the dependency graph static, we do not update
///        individual dependencies but simply apply the group dependency.
/// 3. the instruction name, given by the state variable to track where
///    dependecy values came from.
#[derive(Debug, Hash, PartialEq, Eq, Serialize)]
pub struct DependencyKey (ComponentName, StateVarSlice, InstructionName);

/// A collection of edges on the dependency graph
/// - Groups and array state var slices get converted into multiple DependencyValues
/// - A dependency applies to every instance, so it refers to instances relatively.
/// For example:
/// If A, a component inside a map, depends on B, a component inside a map
/// in the map, then each instance of A depends on a different instance of B.
/// But their relative instance is the same, and that is what to store
/// in the dependency graph.
#[derive(Debug, Serialize, PartialEq, Eq)]
pub enum Dependency {
    Essential {
        component: ComponentRelative,
        origin: EssentialDataOrigin,
    },
    StateVar {
        states: GroupStateSliceRelative,
    },
    StateVarArrayCorrespondingElement {
        array_state: ComponentRefStateArrayRelative,
    },
    StateVarArrayDynamicElement {
        array_state: ComponentRefStateArrayRelative,
        index_state_var: StateRef, // an integer from the component that carries this dependency
    },
    MapSources {
        map_sources: ComponentRelative, // sources component, a collection
        state_var_slice: StateVarSlice,
    },
    /// Necessary when a child dependency instruction encounters a groups
    /// whose members replace themselves with (unknown) children
    /// For example, <template> inside <map>, or <case> inside <conditionalContent>
    /// Implementation is WIP
    UndeterminedChildren {
        component: ComponentRelative,
        desired_profiles: Vec<ComponentProfile>,
    },
}

/// Defines which components form the members of a collection.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, enum_as_inner::EnumAsInner)]
pub enum CollectionMembers {
    Component(ComponentRelative),

    Batch(ComponentRelative),

    /// Only included if the boolean state var is true
    ComponentOnCondition {
        component: ComponentRelative,
        condition: StateRef, // a boolean
    },

    /// The members of this are the same component, but different instances
    InstanceBySources {
        template: ComponentRelative,
        sources: ComponentRelative, // a collection
    },

    // /// Points to collection of whose members are undetermined children of a certain type
    // UndeterminedChildren(ComponentName),
}





pub fn create_doenet_core(
    program: &str,
    existing_essential_data: Option<HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>>,
) -> Result<(DoenetCore, Vec<DoenetMLWarning>), DoenetMLError> {

    log!("===== DoenetCore creation =====");

    // Create component nodes and attributes
    let (ml_components, component_attributes, root_component_name, map_sources_alias) =
        parse_json::create_components_tree_from_json(program)?;

    let mut doenet_ml_warnings = vec![];

    let component_nodes = convert_ml_components_into_component_nodes(ml_components, map_sources_alias, &mut doenet_ml_warnings)?;

    doenet_ml_warnings.extend(check_for_invalid_childen_component_profiles(&component_nodes));
    check_for_cyclical_copy_sources(&component_nodes)?;
    check_for_invalid_component_names(&component_nodes, &component_attributes)?;

    let collection_members = fill_collection_members(&component_nodes);
    let (dependencies, essential_data) = create_dependencies_and_essential_data(
        &component_nodes,
        &component_attributes,
        existing_essential_data
    );
    check_for_cyclical_dependencies(&dependencies)?;

    let component_states = create_stale_component_states(&component_nodes);

    log_json!("Component tree upon core creation",
        utils::json_components(&component_nodes, &component_states));
    log_json!("Dependencies",
        utils::json_dependencies(&dependencies));
    log_json!("Collections",
        &collection_members);
    log_json!("Essential data upon core creation",
        utils::json_essential_data(&essential_data));
    // log_debug!("DoenetCore creation warnings, {:?}", doenet_ml_warnings);

    Ok((DoenetCore {
        component_nodes,
        component_states,
        root_component_name,
        dependencies,
        collection_members,
        essential_data,
    }, doenet_ml_warnings))
}


/// Add CopySource info
fn convert_ml_components_into_component_nodes(
    ml_components: HashMap<ComponentName, MLComponent>,
    map_sources_alias: HashMap<String, String>,
    doenet_ml_warnings: &mut Vec<DoenetMLWarning>,
) -> Result<HashMap<ComponentName, ComponentNode>, DoenetMLError> {
    let mut component_nodes = HashMap::new();
    for (name, ml_component) in ml_components.iter() {
        
        let copy_source = copy_source_for_ml_component(
            &ml_components,
            ml_component,
            &map_sources_alias,
            doenet_ml_warnings,
        )?;

        let component_node = ComponentNode {
            name: name.clone(),
            parent: ml_component.parent.clone(),
            children: ml_component.children.clone(),
            copy_source,
            static_attributes: ml_component.static_attributes.clone(),
            definition: ml_component.definition,
        };

        component_nodes.insert(name.clone(), component_node);
    }

    Ok(component_nodes)
}

fn copy_source_for_ml_component(
    ml_components: &HashMap<ComponentName, MLComponent>,
    ml_component: &MLComponent,
    map_sources_alias: &HashMap<String, String>,
    doenet_ml_warnings: &mut Vec<DoenetMLWarning>,
) -> Result<Option<CopySource>, DoenetMLError> {

    let source_comp_name = ml_component.copy_source.as_ref();
    if source_comp_name.is_none() {
        return Ok(None);
    }
    let source_comp_name = source_comp_name.unwrap();

    if let Some(map_source) = map_sources_alias.get(source_comp_name) {
        let source_comp = ml_components
            .get(map_source)
            .ok_or(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_comp_name.clone(),
                doenetml_range: RangeInDoenetML::None,
            })?;
        let relative_instance = calculate_relative_instance(ml_components, ml_component, source_comp, vec![]);
        let copy_map_source = ComponentRelative {
            name: map_source.clone(),
            relative_instance,
        };
        return Ok(Some(CopySource::MapSources(copy_map_source)));
    }

    let source_comp = ml_components
        .get(source_comp_name)
        .ok_or(DoenetMLError::ComponentDoesNotExist {
            comp_name: source_comp_name.clone(),
            doenetml_range: RangeInDoenetML::None,
        })?;
    let copy_instance = ml_component.copy_instance.clone().unwrap_or_default();
    let relative_instance = calculate_relative_instance(ml_components, ml_component, source_comp, copy_instance);
    let copy_node_relative = ComponentRelative {
        name: source_comp_name.clone(),
        relative_instance,
    };

    let component_index = &ml_component.component_index;
    let (copy_ref_relative, source_def) = match (component_index.len(), component_index.first()) {
        (1, Some(ObjectName::String(first_string))) => {

            // static index
            let string_value = first_string.parse().unwrap_or(0.0);
            let index: usize = convert_float_to_usize(string_value)
                .unwrap_or(0);

            if index == 0 {
                doenet_ml_warnings.push(DoenetMLWarning::PropIndexIsNotPositiveInteger {
                    comp_name: ml_component.name.clone(),
                    invalid_index: string_value.to_string()
                });
            }

            match (&ml_component.copy_collection, &source_comp.definition.replacement_components) {
                (None, Some(ReplacementComponents::Batch(def)))  => {
                    (ComponentRefRelative::Component(BatchMemberRel(copy_node_relative, None, index)),
                    def.member_definition)
                },
                (None, Some(ReplacementComponents::Collection(def)))  => {
                    (ComponentRefRelative::CollectionMember(copy_node_relative, index),
                    (def.member_definition)(&source_comp.static_attributes))
                },
                (Some(key), _) => {
                    let (batch_name, batch_def)  = source_comp.definition.batches
                        .get_key_value_ignore_case(key).unwrap();
                    (ComponentRefRelative::Component(BatchMemberRel(copy_node_relative, Some(batch_name), index)),
                    batch_def.member_definition)
                },
                (None, _)  => panic!("not a group"),
            }
        },
        (0, _) => {

            // no index
            (ComponentRefRelative::Component(NodeRel(copy_node_relative)), source_comp.definition)
        }
        (_, _) => {

            // dynamic index
            todo!("dynamic component index");
        },
    };

    let copy_prop = ml_component.copy_prop.as_ref();
    if copy_prop.is_none() {
        if !std::ptr::eq(ml_component.definition, source_def) {
            return Err(DoenetMLError::ComponentCannotCopyOtherType {
                component_name: ml_component.name.clone(),
                component_type: ml_component.definition.component_type,
                source_type: &source_def.component_type,
                doenetml_range: RangeInDoenetML::None,
            });
        }

        return Ok(Some(CopySource::Component(copy_ref_relative)));
    }
    let copy_prop = copy_prop.unwrap();

    if let Some(state_ref) = source_def.array_aliases.get(copy_prop.as_str()) {
        return Ok(Some(CopySource::StateVar(ComponentRefStateRelative(copy_ref_relative, state_ref.clone()))))
    }

    let source_sv_name = source_def
        .state_var_definitions
        .get_key_value_ignore_case(copy_prop.as_str())
        .ok_or(DoenetMLError::StateVarDoesNotExist {
            comp_name: source_comp.name.clone(),
            sv_name: copy_prop.clone(),
            doenetml_range: RangeInDoenetML::None,
        })?
        .0;

    let source_sv_def = source_def
        .state_var_definitions
        .get(source_sv_name)
        .unwrap();

    let prop_index = &ml_component.prop_index;
    match (prop_index.len(), prop_index.first()) {
        (1, Some(ObjectName::String(first_string))) => {

            // static index
            let string_value = first_string.parse().unwrap_or(0.0);
            let index: usize = convert_float_to_usize(string_value)
                .unwrap_or(0);

            if index == 0 {
                doenet_ml_warnings.push(DoenetMLWarning::PropIndexIsNotPositiveInteger {
                    comp_name: ml_component.name.clone(),
                    invalid_index: string_value.to_string()
                });
            }

            if !source_sv_def.is_array() {
                return Err(DoenetMLError::CannotCopyIndexForStateVar {
                    source_comp_name: copy_ref_relative.of_node_relative().name.clone(),
                    source_sv_name,
                    doenetml_range: RangeInDoenetML::None,
                });
            }

            Ok(Some(CopySource::StateVar(ComponentRefStateRelative(
                copy_ref_relative,
                StateRef::ArrayElement(source_sv_name, index)
            ))))
        },
        (0, _) => {

            // no index
            if source_sv_def.is_array() {
                return Err(DoenetMLError::CannotCopyArrayStateVar {
                    source_comp_name: copy_ref_relative.of_node_relative().name.clone(),
                    source_sv_name,
                    doenetml_range: RangeInDoenetML::None,
                });
            }
            Ok(Some(CopySource::StateVar(ComponentRefStateRelative(
                copy_ref_relative,
                StateRef::Basic(source_sv_name)
            ))))
        },
        (_, _) => {

            // dynamic index
            let variable_components = ml_component.prop_index.iter()
                .filter_map(|obj| obj.as_component().map(|c| c.clone()))
                .collect();

            Ok(Some(CopySource::DynamicElement(
                ComponentRefStateArrayRelative(copy_ref_relative, source_sv_name),
                MathExpression::new(&ml_component.prop_index),
                variable_components,
            )))
        },
    }
}

fn fill_collection_members(component_nodes: &HashMap<ComponentName, ComponentNode>)
    -> HashMap<ComponentName, Vec<CollectionMembers>> {

    let mut collection_members = HashMap::new();
    for component in component_nodes.values() {
        if let Some(ReplacementComponents::Collection(def)) = &component.definition.replacement_components {

            let deps = (def.collection_members)(
                &component,
                &component_nodes,
            );
            collection_members.insert(component.name.clone(), deps);
        }
    }

    // flatten so that collections do not point to other collections
    fn flat_members_for_collection(
        component_nodes: &HashMap<ComponentName, ComponentNode>,
        collection_members: &HashMap<ComponentName, Vec<CollectionMembersOrCollection>>,
        component: &ComponentRelative,
    ) -> Vec<CollectionMembers> {
        collection_members.get(&component.name).unwrap()
            .iter()
            .flat_map(|c| {
                match c {
                    CollectionMembersOrCollection::Collection(c) =>
                        flat_members_for_collection(component_nodes, collection_members, c),
                    CollectionMembersOrCollection::Members(m) => vec![m.clone()],
                }
            }).collect()
    }

    let collection_members =  collection_members.iter()
        .map(|(k, _v)| (k.clone(), flat_members_for_collection(
            component_nodes,
            &collection_members,
            &ComponentRelative::same_instance(k.clone())
        ))).collect();

    collection_members
}

fn create_dependencies_and_essential_data(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_attributes: &HashMap<ComponentName, HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>>,
    existing_essential_data: Option<HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>>,
) -> (HashMap<DependencyKey, Vec<Dependency>>, HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>) {

    let mut all_state_var_defs: Vec<(&ComponentName, StateVarName, &StateVarVariant)> = Vec::new();
    for (_, comp) in component_nodes.iter() {
        for (sv_name, sv_def) in comp.definition.state_var_definitions {
            all_state_var_defs.push((&comp.name, sv_name, sv_def));
        }
    }

    let mut element_specific_dependencies: HashMap<(ComponentName, StateVarName), Vec<usize>> = HashMap::new();

    for (comp_name, sv_name, sv_def) in all_state_var_defs {
        if !sv_def.is_array() {
            continue;
        }

        let comp = component_nodes.get(comp_name).unwrap();

        let possible_attributes = if let Some(my_own_comp_attrs) = component_attributes.get(comp_name) {
            Some(my_own_comp_attrs)
        } else if let Some(CopySource::Component(..)) = comp.copy_source {
            let component_relative = get_recursive_copy_source_component_when_exists(&component_nodes, comp);
            component_attributes.get(&component_relative.name)
        } else {
            None
        };

        if let Some(attribute_for_comp) = possible_attributes {

            if let Some(attribute_for_sv) = attribute_for_comp.get(sv_name) {
                let element_dep_flags: Vec<usize> = attribute_for_sv.iter().map(|(id, _)| *id).collect();
                element_specific_dependencies.insert(
                    (comp_name.clone(), sv_name),
                    element_dep_flags
                );
            }
        }
    }

    // Fill in component_states and dependencies HashMaps for every component
    // and supply any essential_data required by dependencies.
    let should_initialize_essential_data = existing_essential_data.is_none();
    let mut essential_data = existing_essential_data.unwrap_or(HashMap::new());

    let mut dependencies = HashMap::new();

    for component in component_nodes.values() {

        let dependencies_for_this_component = create_all_dependencies_for_component(
            &component_nodes,
            component,
            component_attributes.get(&component.name).unwrap_or(&HashMap::new()),
            // copy_index_flags.get(component_name).as_deref(),
            &mut essential_data,
            should_initialize_essential_data,
            &element_specific_dependencies,
        );
        dependencies.extend(dependencies_for_this_component);



    }
    (dependencies, essential_data)
}

fn create_all_dependencies_for_component<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
    component_attributes: &'a HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    // copy_index_flag: Option<&(ComponentName, StateVarName, Vec<ObjectName>)>,
    essential_data: &'a mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
    element_specific_dependencies: &'a HashMap<(ComponentName, StateVarName), Vec<usize>>,
) -> HashMap<DependencyKey, Vec<Dependency>> {

    // log_debug!("Creating dependencies for {}", component.name);
    let mut dependencies: HashMap<DependencyKey, Vec<Dependency>> = HashMap::new();
    let my_definitions = component.definition.state_var_definitions;

    if let Some(CopySource::DynamicElement(_, ref expression, ref variable_components)) = component.copy_source {
        // We can't immediately figure out the index, so we need to use the state
        // var propIndex
        dependencies.extend(
            create_prop_index_dependencies(component, components, expression, variable_components, essential_data)
        );
    }

    for (&state_var_name, state_var_variant) in my_definitions {

        if state_var_variant.is_array() {

            let size_dep_instructions = state_var_variant
                .return_size_dependency_instructions(HashMap::new());

            let component_slice = ComponentStateSliceAllInstances(
                component,
                StateVarSlice::Single(StateRef::SizeOf(state_var_name))
            );
            for (instruct_name, ref dep_instruction) in size_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    &component_slice,
                    component_attributes,
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data,
                );

                dependencies.insert(
                    DependencyKey(component_slice.0.name.clone(), component_slice.1.clone(), instruct_name),
                    instruct_dependencies,
                );

            }

            let array_dep_instructions = state_var_variant
                .return_array_dependency_instructions(HashMap::new());

            let component_slice = ComponentStateSliceAllInstances(
                component,
                StateVarSlice::Array(state_var_name),
            );
            for (instruct_name, ref dep_instruction) in array_dep_instructions.into_iter() {
                let instruct_dependencies =
                    create_dependencies_from_instruction(
                        &components,
                        &component_slice,
                        component_attributes,
                        dep_instruction,
                        instruct_name,
                        essential_data,
                        should_initialize_essential_data
                    );

                dependencies.insert(
                    DependencyKey(component_slice.0.name.clone(), component_slice.1.clone(), instruct_name),
                    instruct_dependencies,
                );
            }

            // make dependencies for elements when size has an essential value
            // let elements = {
                // let source_comp_name = get_essential_data_component_including_copy(components, component);

                // let size = essential_data
                //     .get(source_comp_name)
                //     .and_then(|c| c
                //         .get(&EssentialDataOrigin::StateVar(state_var_name))
                //         .and_then(|s| s
                //             .get_value(StateIndex::SizeOf)
                //             .and_then(|v|
                //                 usize::try_from(v).ok()
                //             )
                //         )
                //     ).unwrap_or(0);

                // indices_for_size(size)
            // };
            let empty = &Vec::new();

            let elements = element_specific_dependencies.get(&(component.name.clone(), state_var_name)).unwrap_or(empty);

            // TODO: change this hack
            let mut elements = elements.clone();
            if !elements.contains(&1) {
                elements.push(1)
            }
            if !elements.contains(&2) {
                elements.push(2)
            }

            log_debug!("Will make dependencies for elements {:?} of {}", elements, component_slice);

            for index in elements {

                let element_dep_instructions = state_var_variant
                    .return_element_dependency_instructions(index, HashMap::new());

                let component_slice = ComponentStateSliceAllInstances(
                    component,
                    StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                );
                for (instruct_name, ref dep_instruction) in element_dep_instructions.into_iter() {
                    let instruct_dependencies =
                        create_dependencies_from_instruction(
                            &components,
                            &component_slice,
                            component_attributes,
                            dep_instruction,
                            instruct_name,
                            essential_data,
                            should_initialize_essential_data
                        );

                    dependencies.insert(
                        DependencyKey(component_slice.0.name.clone(), component_slice.1.clone(), instruct_name),
                        instruct_dependencies,
                    );
                }
            }


        } else {

            let dependency_instructions = state_var_variant.return_dependency_instructions(HashMap::new());

            let component_slice = ComponentStateSliceAllInstances(
                component,
                StateVarSlice::Single(StateRef::Basic(state_var_name)),
            );
            for (instruct_name, ref dep_instruction) in dependency_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    &component_slice,
                    component_attributes,
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data
                );

                dependencies.insert(
                    DependencyKey(component_slice.0.name.clone(), component_slice.1.clone(), instruct_name),
                    instruct_dependencies   
                );
            }

        }
    }

    dependencies

}

/// This function also creates essential data when a DependencyInstruction asks for it.
/// The second return is element specific dependencies.
fn create_dependencies_from_instruction(
    components: &HashMap<ComponentName, ComponentNode>,
    component_slice: &ComponentStateSliceAllInstances,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    instruction: &DependencyInstruction,
    instruction_name: InstructionName,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
) -> Vec<Dependency> {

    log_debug!("Creating dependency {}:{} from instruction {:?}", component_slice, instruction_name, instruction);

    let component = component_slice.0;
    let state_var_slice = &component_slice.1;

    match &instruction {

        DependencyInstruction::Essential { prefill } => {

            let source_relative = get_recursive_copy_source_component_when_exists(components, component);
            let essential_origin = EssentialDataOrigin::StateVar(state_var_slice.name());

            if should_initialize_essential_data && source_relative.name == component.name {
                // Components only create their own essential data

                let sv_def = component.definition.state_var_definitions.get(state_var_slice.name()).unwrap();

                let initial_data: StateVarValue = prefill
                    .and_then(|prefill_attr_name| component_attributes
                        .get(prefill_attr_name)
                        .and_then(|attr| {
                            attr.get(&1).unwrap()
                                .first().unwrap()
                                .as_string().and_then(|actual_str|
                                    package_string_as_state_var_value(actual_str.to_string(), sv_def).ok(),
                                )
                            })
                        )
                    .unwrap_or(sv_def.initial_essential_value());

                let initial_data = if sv_def.is_array() {
                    InitialEssentialData::Array(Vec::new(), initial_data)
                } else {
                    InitialEssentialData::Single(initial_data)
                };
    
                create_essential_data_for(
                    &source_relative.name,
                    components,
                    essential_origin.clone(),
                    initial_data,
                    essential_data
                );
            }

            vec![Dependency::Essential {
                component: source_relative,
                origin: essential_origin,
            }]
        },

        DependencyInstruction::StateVar { component_ref, state_var } => {

            let component_ref = component_ref.clone()
                .unwrap_or(ComponentRefRelative::node(component_slice.0.name.clone()));

            let states = GroupStateSliceRelative(
                ComponentGroupRelative::Single(component_ref),
                state_var.clone()
            );
            vec![Dependency::StateVar { states }]
        },

        DependencyInstruction::CorrespondingElements { component_ref, array_state_var_name } => {

            let component_ref = component_ref.clone()
                .unwrap_or(ComponentRefRelative::node(component_slice.0.name.clone()));

            vec![Dependency::StateVarArrayCorrespondingElement {
                array_state: ComponentRefStateArrayRelative(component_ref.into(), array_state_var_name),
            }]
        },

        DependencyInstruction::Parent { state_var } => {

            let parent_name = component.parent.clone().expect(&format!(
                "Component {}:{} asks for a parent but there is none.",
                    component_slice, instruction_name
            ));

            // Look up what kind of child state var it is
            // If the state var is an array, depend on the array, otherwise as normal
            let parent_component = components.get(&parent_name).unwrap();
            let sv_def = parent_component.definition.state_var_definitions.get(state_var).unwrap();
            let sv_slice = if sv_def.is_array() {
                    StateVarSlice::Array(state_var)
                } else {
                    StateVarSlice::Single(StateRef::Basic(state_var))
                };
            let relative_instance = 
                if component.definition.component_type == "template"
                && parent_component.definition.component_type == "map" {
                    RelativeInstance(1, Vec::new())
                } else {
                    RelativeInstance::default()
                };
            let parent_ref = ComponentRefRelative::Component(NodeRel(ComponentRelative {
                name: parent_name,
                relative_instance,
            }));

            let states = GroupStateSliceRelative(
                ComponentGroupRelative::Single(parent_ref),
                sv_slice
            );
            vec![Dependency::StateVar { states }]
        },

        DependencyInstruction::Child { desired_profiles, parse_into_expression } => {

            enum RelevantChild<'a> {
                StateVar(Dependency),
                String(&'a String, &'a ComponentNode), // value, parent name
            }

            let mut relevant_children: Vec<RelevantChild> = Vec::new();
            let mut can_parse_into_expression = *parse_into_expression;
            
            let source_relative =
                get_recursive_copy_source_component_when_exists(components, component);
            let source = components.get(&source_relative.name).unwrap();
            
            if let Some(CopySource::StateVar(ref component_state_relative)) = source.copy_source {
                // copying a state var means we don't inheret its children,
                // so we depend on it directly
                let states = GroupStateSliceRelative(
                    ComponentGroupRelative::Single(component_state_relative.0.clone()),
                    StateVarSlice::Single(component_state_relative.1.clone())
                );
                relevant_children.push(
                    RelevantChild::StateVar(Dependency::StateVar { states })
                );
            } else if let Some(CopySource::DynamicElement(ref source_array, _, _)) = source.copy_source {
                relevant_children.push(
                    RelevantChild::StateVar(Dependency::StateVarArrayDynamicElement {
                        array_state: source_array.clone(),
                        index_state_var: StateRef::Basic(PROP_INDEX_SV),
                    })
                );
            } else if let Some(CopySource::Component(ref component_ref_relative)) = source.copy_source {
                if matches!(component_ref_relative, ComponentRefRelative::Component(BatchMemberRel(_, _, _))) {
                    // a batch member has no children, so we depend on it directly
                    let states = GroupStateSliceRelative(
                        ComponentGroupRelative::Single(component_ref_relative.clone()),
                        state_var_slice.clone()
                    );
                    relevant_children.push(
                        RelevantChild::StateVar(Dependency::StateVar { states })
                    );
                }
            } else if let Some(CopySource::MapSources(map_sources)) = &component.copy_source {
                relevant_children.push(
                    RelevantChild::StateVar(Dependency::MapSources {
                        map_sources: map_sources.clone(),
                        state_var_slice: state_var_slice.clone(),
                    })
                );
            }


            let children = get_child_nodes_including_copy(components, component);

            for child in children.iter() {

                match child {
                    (ComponentChild::Component(child_name), _) => {

                        let child_node = components.get(child_name).unwrap();
                        let instance = source_relative.relative_instance.clone();
                        let child_node_relative = ComponentRelative {
                            name: child_name.clone(),
                            relative_instance: instance,
                        };

                        let child_group = match child_node.definition.replacement_components {
                            Some(ReplacementComponents::Batch(_)) =>
                                ComponentGroupRelative::Batch(child_node_relative),
                            Some(ReplacementComponents::Collection(_)) =>
                                ComponentGroupRelative::Collection(child_node_relative),
                            Some(ReplacementComponents::Children) => panic!("replace children outside group, not implemented"),
                            None => ComponentGroupRelative::Single(ComponentRefRelative::Component(NodeRel(child_node_relative))),
                        };
                        let child_def = definition_as_replacement_child(child_node);

                        if matches!(child_def.replacement_components, Some(ReplacementComponents::Children)) {
                            // cannot permanently parse into an expression when the type and number of children could change
                            can_parse_into_expression = false;
                            relevant_children.push(
                                RelevantChild::StateVar(Dependency::UndeterminedChildren {
                                    component: ComponentRelative::same_instance(child_name.clone()),
                                    desired_profiles: desired_profiles.clone(),
                                })
                            );
                        }

                        if let Some(profile_sv_slice) = child_def.component_profile_match(desired_profiles) {
                            let states = GroupStateSliceRelative(child_group, profile_sv_slice);
                            relevant_children.push(
                                RelevantChild::StateVar(Dependency::StateVar { states })
                            );
                        }
                    },
                    (ComponentChild::String(string_value), actual_parent) => {
                        if desired_profiles.contains(&ComponentProfile::Text)
                            || desired_profiles.contains(&ComponentProfile::Number) {
                            relevant_children.push(
                                RelevantChild::String(string_value, actual_parent)
                            );
                        }
                    },
                }
            }

            let mut dependencies = Vec::new();

            if can_parse_into_expression {

                // Assuming for now that expression is math expression
                let expression = MathExpression::new(
                    &relevant_children.iter().map(|child| match child {
                        // The component name doesn't matter, the expression just needs to know there is
                        // an external variable at that location
                        RelevantChild::StateVar(_) => ObjectName::Component(String::new()),
                        RelevantChild::String(string_value, _) => ObjectName::String(string_value.to_string()),
                    }).collect()
                );

                // Assuming that no other child instruction exists which has already filled
                // up the child essential data
                let essential_origin = EssentialDataOrigin::ComponentChild(0);

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        components,
                        essential_origin.clone(),
                        InitialEssentialData::Single(
                            StateVarValue::MathExpr(expression),
                        ),
                        essential_data
                    );    
                }

                dependencies.push(Dependency::Essential {
                    component: ComponentRelative::same_instance(component.name.clone()),
                    origin: essential_origin,
                });

                // We already dealt with the essential data, so now only retain the component children
                relevant_children.retain(|child| matches!(child, RelevantChild::StateVar(_)));
                
            }

            // Stores how many string children added per parent.
            let mut essential_data_numbering: HashMap<ComponentName, usize> = HashMap::new();

            for relevant_child in relevant_children {
                match relevant_child {

                    RelevantChild::StateVar(child_dep) => {
                        dependencies.push(child_dep);
                    },

                    RelevantChild::String(string_value, actual_parent) => {
                        let index = essential_data_numbering
                            .entry(actual_parent.name.clone()).or_insert(0 as usize);

                        let essential_origin = EssentialDataOrigin::ComponentChild(*index);

                        if should_initialize_essential_data && std::ptr::eq(component, actual_parent) {
                            // Components create their own essential data

                            let value = StateVarValue::String(string_value.clone());
                            create_essential_data_for(
                                &actual_parent.name,
                                components,
                                essential_origin.clone(),
                                InitialEssentialData::Single(value),
                                essential_data
                            );
                        }

                        dependencies.push(Dependency::Essential {
                            component: ComponentRelative::same_instance(actual_parent.name.clone()),
                            origin: essential_origin,
                        });

                        *index += 1;
                    },
                }
            }
            
            dependencies
        },

        DependencyInstruction::Attribute { attribute_name, index } => {

            // log_debug!("Getting attribute {} for {}", attribute_name, component_slice);
            let state_var_name = state_var_slice.name();
            let state_var_ref = StateRef::from_name_and_index(state_var_name, *index);
            let sv_def = component.definition.state_var_definitions.get(state_var_name).unwrap();
            let essential_origin = EssentialDataOrigin::StateVar(state_var_name);


            let default_value = match sv_def {

                StateVarVariant::NumberArray(_)| 
                StateVarVariant::Number(_) | 
                StateVarVariant::Integer(_) => {
                    StateVarValue::MathExpr(MathExpression::new(
                        &vec![ObjectName::String(match sv_def.initial_essential_value() {
                            StateVarValue::Number(v) => v.to_string(),
                            StateVarValue::Integer(v) => v.to_string(),
                            _ => unreachable!(),
                        })]
                    ))
                },
                _ => sv_def.initial_essential_value(),
            };

            let attribute = component_attributes.get(*attribute_name);
            if attribute.is_none() {
                if let Some(CopySource::Component(component_ref_relative)) = &component.copy_source {

                    // inherit attribute from copy source
                    let states = GroupStateSliceRelative(
                        ComponentGroupRelative::Single(component_ref_relative.clone()),
                        StateVarSlice::Single(state_var_ref)
                    );
                    return vec![Dependency::StateVar { states }]
                }

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        components,
                        EssentialDataOrigin::StateVar(state_var_name),
                        InitialEssentialData::Single(default_value),
                        essential_data
                    );    
                }

                return vec![Dependency::Essential {
                    component: ComponentRelative::same_instance(component.name.clone()),
                    origin: essential_origin,
                }]
            }

            // attribute specified
            let attribute = attribute.unwrap();

            // log_debug!("attribute {:?}", attribute);

            // Create the essential data if it does not exist yet
            if should_initialize_essential_data && !essential_data_exists_for(&component.name, &essential_origin, essential_data) {

                let get_value_from_object_list = |obj_list: &Vec<ObjectName>| -> StateVarValue {

                    if matches!(sv_def, StateVarVariant::Number(_)
                        | StateVarVariant::NumberArray(_)
                        | StateVarVariant::Integer(_)
                        | StateVarVariant::Boolean(_)
                    ) {
                        StateVarValue::MathExpr(
                            MathExpression::new(obj_list)
                        )
                    } else if obj_list.len() > 0 {

                        let first_obj = obj_list.get(0).unwrap();
                        if obj_list.len() > 1 {
                            unimplemented!("Multiple objects for non mathexpression state var");
                        }
                        match first_obj {
                            ObjectName::String(str_val) => {
                                package_string_as_state_var_value(str_val.to_string(), &sv_def).unwrap()
                            }
                            _ => default_value.clone()
                        }
                    } else {
                        default_value.clone()
                    }
                };

                let initial_essential_data;
                if sv_def.is_array() {

                    let mut essential_attr_objs: Vec<StateVarValue> = Vec::new();
                    
                    for (id, obj_list) in attribute {

                        let value = get_value_from_object_list(obj_list);

                        if *id > essential_attr_objs.len() {
                            essential_attr_objs.resize(*id, default_value.clone());
                        }
                        essential_attr_objs[id - 1] = value;
                    }

                    // log_debug!("essential attributes {:?}", essential_attr_objs);

                    initial_essential_data = InitialEssentialData::Array(essential_attr_objs, default_value);

                } else {

                    assert_eq!(attribute.keys().len(), 1);
                    let obj_list = attribute.get(&1).unwrap();

                    // log_debug!("Initializing non-array essential data for {} from attribute data {:?}", component_slice, obj_list);

                    let value = get_value_from_object_list(obj_list);
                    initial_essential_data = InitialEssentialData::Single(value);                    
                }

                create_essential_data_for(
                    &component.name,
                    components,
                    essential_origin.clone(),
                    initial_essential_data,
                    essential_data,
                );
            }



            if matches!(index, StateIndex::SizeOf) {
                // size does not depend on referenced objects
                return vec![Dependency::Essential {
                    component: ComponentRelative::same_instance(component.name.clone()),
                    origin: essential_origin,
                }]
            }

            let attribute_index = match index {
                StateIndex::Element(i) => *i,
                _ => 1,
            };

            let attr_objects = attribute.get(&attribute_index)
                .expect(&format!("attribute {} does not have index {}. Attribute: {:?}",
                    component_slice, &attribute_index, attribute));

            let mut dependencies = Vec::new();

            let relevant_attr_objects = match sv_def {
                StateVarVariant::Number(_) |
                StateVarVariant::NumberArray(_) |
                StateVarVariant::Integer(_) => {
                    // First add an essential dependency to the expression
                    dependencies.push(Dependency::Essential {
                        component: ComponentRelative::same_instance(component.name.clone()),
                        origin: essential_origin.clone(),
                    });

                    attr_objects.into_iter().filter_map(|obj|
                        matches!(obj, ObjectName::Component(_)).then(|| obj.clone())
                    ).collect()
                },
                _ => attr_objects.clone(),
            };

            for attr_object in relevant_attr_objects {

                let dependency = match attr_object {
                    ObjectName::String(_) => Dependency::Essential {
                        component: ComponentRelative::same_instance(component.name.clone()),
                        origin: essential_origin.clone(),
                    },
                    ObjectName::Component(comp_name) => {
                        let comp = components.get(&comp_name).unwrap();
                        let primary_input_sv = comp.definition.primary_input_state_var.expect(
                            &format!("An attribute cannot depend on a non-primitive component. Try adding '.value' to the macro.")
                        );

                        let component_group_relative = ComponentGroupRelative::Single(ComponentRefRelative::node(comp_name.clone()));
                        let states = GroupStateSliceRelative(
                            component_group_relative,
                            StateVarSlice::Single(StateRef::Basic(primary_input_sv))
                        );
                        Dependency::StateVar { states }
                    },
                };

                dependencies.push(dependency);
            }

            dependencies
        },
    }
}

fn create_prop_index_dependencies<'a>(
    component: &'a ComponentNode,
    components: &'a HashMap<ComponentName, ComponentNode>,
    math_expression: &'a MathExpression,
    variable_components: &'a Vec<ComponentName>,
    essential_data: &'a mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
)
-> HashMap<DependencyKey, Vec<Dependency>> {
    use base_definitions::*;

    let mut dependencies = HashMap::new();

    // Dependencies on source components for propIndex
    let component_slice = ComponentStateSliceAllInstances(
        component,
        StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV))
    );
    dependencies.insert(
        DependencyKey(component_slice.0.name.clone(), component_slice.1.clone(), PROP_INDEX_VARS_INSTRUCTION),
        variable_components.iter().map(|comp_name| {
            let slice = StateVarSlice::Single(StateRef::Basic("value"));
            let states = GroupStateSliceRelative(
                ComponentGroupRelative::Single(ComponentRefRelative::node(comp_name.clone())),
                slice
            );
            Dependency::StateVar { states }
        }).collect()
    );

    let origin = EssentialDataOrigin::StateVar(PROP_INDEX_SV);

    create_essential_data_for(
        &component.name,
        components,
        origin.clone(),
        InitialEssentialData::Single(StateVarValue::MathExpr(math_expression.clone())),
        essential_data,
    );

    // Dependency on math expression for propIndex
    dependencies.insert(
        DependencyKey(component_slice.0.name.clone(), component_slice.1, PROP_INDEX_EXPR_INSTRUCTION),
        vec![Dependency::Essential {
            component: ComponentRelative::same_instance(component.name.clone()),
            origin,
        }]
    );

    dependencies
}

fn package_string_as_state_var_value(input_string: String, state_var_variant: &StateVarVariant)
    -> Result<StateVarValue, String> {

    match state_var_variant {
        StateVarVariant::StringArray(_) |
        StateVarVariant::String(_) => {
            Ok(StateVarValue::String(input_string))
        },

        StateVarVariant::Boolean(_) => {

            if input_string == "true" {
                Ok(StateVarValue::Boolean(true))
            } else if input_string == "false" {
                Ok(StateVarValue::Boolean(false))
            } else {
                Err(format!("Cannot evaluate string '{}' as boolean", input_string))
            }
        },

        StateVarVariant::Integer(_) => {
            if let Ok(val) = evalexpr::eval_int(&input_string) {
                Ok(StateVarValue::Integer(val))
            } else {
                Err(format!("Cannot package string '{}' as integer", input_string))
        }
        },

        StateVarVariant::NumberArray(_) |
        StateVarVariant::Number(_) => {
            if let Ok(val) = evalexpr::eval_number(&input_string) {
                Ok(StateVarValue::Number(val))
            } else {
                Err(format!("Cannot package string '{}' as number", input_string))
            }
        },
    }
}

/// Recurse until the name of the original source is found.
/// This allows copies to share essential data.
fn get_recursive_copy_source_component_when_exists(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
) -> ComponentRelative {
    match &component.copy_source {
        Some(CopySource::Component(ComponentRefRelative::Component(NodeRel(source)))) => {
            let component_relative = get_recursive_copy_source_component_when_exists(
                components,
                &components.get(&source.name).unwrap(),
            );
            let instance = source.relative_instance.clone().add_relative(component_relative.relative_instance);
            ComponentRelative {
                name: component_relative.name,
                relative_instance: instance,
            }
        },
        _ => ComponentRelative::same_instance(component.name.clone()),
    }
}



#[derive(Debug, Clone)]
struct EssentialState<'a> (ComponentInstance<'a>, EssentialDataOrigin, StateIndex);

/// Essential data can be generated by
/// - a state variable requesting it
/// - a string child, converted into essential data
///   so that it can change when requested
/// - a string in an attribute
#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]
pub enum EssentialDataOrigin {
    StateVar(StateVarName),
    ComponentChild(usize),
    // AttributeString(usize),
}

/// A single essential state
enum InitialEssentialData {
    Single(StateVarValue),
    Array(Vec<StateVarValue>, StateVarValue),
}

/// Add essential data for a state variable or string child
fn create_essential_data_for(
    component_name: &ComponentName,
    components: &HashMap<ComponentName, ComponentNode>,
    origin: EssentialDataOrigin,
    initial_values: InitialEssentialData,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) {

    if let Some(comp_essential_data) = essential_data.get(component_name) {
        assert!( !comp_essential_data.contains_key(&origin) );
    }
    let inside_maps = component_inside_maps(components, components.get(component_name).unwrap());

    let essential_state = match initial_values {
        InitialEssentialData::Single(value) =>
            EssentialStateVar::new_single_basic_with_state_var_value(value, inside_maps),
        InitialEssentialData::Array(values, default_fill_value) =>
            EssentialStateVar::new_array_with_state_var_values(values, default_fill_value, inside_maps),
    };

    log_debug!("New essential data for {} {:?} {:?}", component_name, origin, essential_state);

    essential_data
        .entry(component_name.clone())
        .or_insert(HashMap::new())
        .entry(origin.clone())
        .or_insert(essential_state);
}

fn essential_data_exists_for(
    component_name: &ComponentName,
    origin: &EssentialDataOrigin,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> bool {

    if let Some(comp_essen) = essential_data.get(component_name) {
        comp_essen.contains_key(origin)
    } else {
        false
    }
}



fn create_stale_component_states(component_nodes: &HashMap<ComponentName, ComponentNode>)
    -> HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>> {

    let mut component_states = HashMap::new();
    for  component in component_nodes.values() {
        let inside_maps = component_inside_maps(component_nodes, component);

        let mut state_for_this_component: HashMap<StateVarName, StateForStateVar> =
            component.definition.state_var_definitions.iter()
            .map(|(&sv_name, sv_variant)| (sv_name, StateForStateVar::new(&sv_variant, inside_maps)))
            .collect();

        if let Some(CopySource::DynamicElement(_, _, _)) = component.copy_source {
            state_for_this_component.insert(PROP_INDEX_SV, StateForStateVar::new(
                &StateVarVariant::Number(StateVarDefinition::default()),
                inside_maps,
            ));
        }
        component_states.insert(
            component.name.clone(),
            state_for_this_component,
        );
    }
    component_states
}





// A state variable on a ComponentRef corresponds to a ComponentState and must be converted:
// ComponentRefStateSlice -> ComponentGeneratedStateSlice -> ComponentStateSlice
#[derive(Debug, Clone)]
struct ComponentRefStateSlice<'a> (ComponentRef<'a>, StateVarSlice);

#[derive(Debug, Clone)]
struct ComponentGeneratedStateSlice<'a> (ComponentGenerated<'a>, StateVarSlice);

#[derive(Debug, Clone)]
struct ComponentStateSlice<'a> (ComponentInstance<'a>, StateVarSlice);

/// A single state variable
#[derive(Debug, Clone)]
struct ComponentState<'a> (ComponentInstance<'a>, StateRef);

impl<'a> ComponentRefStateSlice<'a> {
    /// If the component reference is a group member, this is not trivial.
    fn convert_to_state_slice(self, core: &'a DoenetCore) -> Option<ComponentStateSlice<'a>> {
        let component_generated = self.0.apply_collection(core)?;
        ComponentGeneratedStateSlice(component_generated, self.1).convert_to_state_slice()
    }
}

impl<'a> ComponentGeneratedStateSlice<'a> {
    fn convert_to_state_slice(self) -> Option<ComponentStateSlice<'a>> {
        match self.0 {
            Node(n) => Some(ComponentStateSlice(n, self.1)),
            BatchMember(n, c, i) =>
                batch_state_var(&ComponentStateSliceAllInstances(n.node, self.1), c, i)
                    .map(|sv| ComponentStateSlice(n, sv)),
        }
    }
}

impl<'a> ComponentRef<'a> {
    fn convert_to_node_instance(self, core: &'a DoenetCore) -> Option<ComponentInstance<'a>> {
        self.apply_collection(core)
            .unwrap()
            .try_into_node()
    }

    fn apply_collection(self, core: &'a DoenetCore) -> Option<ComponentGenerated<'a>> {
        match self {
            ComponentRef::Component(component_generated) => Some(component_generated),
            ComponentRef::CollectionMember(n, i) => nth_collection_member(core, &n, i),
        }
    }
}

fn resolve_state_variable(
    core: &DoenetCore,
    component_state: &ComponentState,
) -> Option<StateVarValue> {

    if let StateRef::ArrayElement(..) = &component_state.1 {
        // resolve the size in case this array element does not exist
        let size_variable = component_state.replace_index(StateIndex::SizeOf);
        resolve_state_variable(core, &size_variable);
    }

    // No need to continue if the state var is already resolved or if the element does not exist
    let current_state = component_state.get_value(&core.component_states);
    if let Some(State::Resolved(current_value)) = current_state {
        return Some(current_value);
    } else if current_state.is_none() {
        // There is nothing to resolve
        log_debug!("{} does not exist", component_state);
        return None
    }

    let my_dependencies = dependencies_of_state_var(&core.dependencies, &component_state.clone().ignore_instance());
    log_debug!(">> Resolving {} \nIt has dependencies {:?}", component_state, my_dependencies);

    let mut dependency_values: HashMap<InstructionName, Vec<DependencyValue>> = HashMap::new();
    for (dep_name, deps) in my_dependencies {
        let mut values_for_this_dep: Vec<DependencyValue> = Vec::new();

        for dep in deps {
            let dependency_source = get_source_for_dependency(&core.component_nodes, &core.essential_data, &dep);

            match dep {
                Dependency::StateVar { states } => {

                    let GroupStateSliceRelative(component_group_relative, component_group_sv_slice) = states;
                    let group_instance = component_group_relative.instance_relative_to(&core.component_nodes, &component_state.0);

                    for component_ref in group_instance.group_members(core) {

                        let comp_ref_slice = ComponentRefStateSlice(component_ref, component_group_sv_slice.clone());
                        let sv_slice = comp_ref_slice.convert_to_state_slice(core).unwrap();

                        values_for_this_dep.extend(
                            get_dependency_values_for_state_var_slice(core, &sv_slice)
                        );
                    }
                },

                Dependency::UndeterminedChildren { component , desired_profiles } => {

                    let group = ComponentGroupRelative::Collection(component.clone());
                    let group_members = group
                        .instance_relative_to(&core.component_nodes, &component_state.0)
                        .group_members(core);

                    let mut children = Vec::new();
                    for component_ref in group_members {
                        children.extend(state_vars_for_undetermined_children(core, component_ref, &desired_profiles));
                    }
                    for (object_slice, dep_source,) in children {
                        match object_slice {
                            ObjectStateVarInstance::Component(slice_variable) => {
                                values_for_this_dep.extend(
                                    get_dependency_values_for_state_var_slice(core, &slice_variable)
                                );

                            },
                            ObjectStateVarInstance::String(s) => {
                                values_for_this_dep.push(DependencyValue {
                                    source: dep_source,
                                    value: StateVarValue::String(s),
                                })
                            },
                        };
                    }

                },

                Dependency::MapSources { map_sources, state_var_slice } => {

                    let component_ref = map_sources_dependency_member(core, &component_state.0, map_sources);

                    // log_debug!("map source ref: {}", component_ref);
                    let comp_ref_slice = ComponentRefStateSlice(component_ref, state_var_slice.clone());
                    let sv_slice = comp_ref_slice.convert_to_state_slice(core).unwrap();

                    values_for_this_dep.extend(
                        get_dependency_values_for_state_var_slice(core, &sv_slice)
                    );
                },
                Dependency::StateVarArrayCorrespondingElement { array_state } => {

                    let (component_ref_relative, sv_slice) = array_state.split_array_with_index(component_state.1.index());
                    let component_ref = component_ref_relative.instance_relative_to(&core.component_nodes, &component_state.0);

                    let comp_ref_slice = ComponentRefStateSlice(component_ref, sv_slice.clone());
                    let sv_slice = comp_ref_slice.convert_to_state_slice(core).unwrap();

                    values_for_this_dep.extend(
                        get_dependency_values_for_state_var_slice(core, &sv_slice)
                    );
                },

                Dependency::Essential { component, origin } => {

                    let dependency_map = component.instance_relative_to(&core.component_nodes, &component_state.0);

                    let index = match origin {
                        EssentialDataOrigin::StateVar(_) => component_state.1.index(),
                        _ => StateIndex::Basic,
                    };

                    let value = core.essential_data
                        .get(&dependency_map.node.name).unwrap()
                        .get(&origin).unwrap()
                        .clone()
                        .get_value(index, &dependency_map.instance);
    
                    if let Some(value) = value {
                        values_for_this_dep.push(DependencyValue {
                            source: dependency_source,
                            value,
                        })
                    }
                },

                Dependency::StateVarArrayDynamicElement { array_state, index_state_var } => {

                    let index_variable = component_state.clone().replace_state_var(index_state_var.clone());
                    let index_value = resolve_state_variable(core, &index_variable);

                    let index: Option<usize> = index_value.and_then(|i|
                        convert_float_to_usize(i.try_into().unwrap())
                    );

                    if let Some(index) = index {

                        // log_debug!("got prop index which is {}", index);

                        let (component_ref_relative, sv_slice) = array_state.split_array_with_index(StateIndex::Element(index));
                        let component_ref = component_ref_relative.instance_relative_to(&core.component_nodes, &component_state.0);

                        let slice_variable = ComponentRefStateSlice(component_ref, sv_slice);
                        let slice_variable = slice_variable.convert_to_state_slice(core).unwrap();

                        values_for_this_dep.extend(
                            get_dependency_values_for_state_var_slice(core, &slice_variable)
                        );
                    }
                }
            }
        }

        dependency_values.insert(dep_name, values_for_this_dep);
    }


    log_debug!("Dependency values for {}: {:#?}", component_state, dependency_values);

    let node = &component_state.0.node;

    let update_instruction = generate_update_instruction_for_state_ref(
        component_state,
        dependency_values,
    ).expect(&format!("Can't resolve {} (a {} component type)",
        component_state, node.definition.component_type)
    );

    let updated_value: Option<StateVarValue>;

    match update_instruction {
        StateVarUpdateInstruction::NoChange => {
            match current_state {
                Some(State::Stale) => 
                    panic!("Cannot use NoChange update instruction on a stale value"),
                Some(State::Resolved(current_resolved_value)) => {
                    // Do nothing. It's resolved, so we can use it as is
                    updated_value = Some(current_resolved_value);
                },
                None => {
                    updated_value = None;
                },
            }
        },
        StateVarUpdateInstruction::SetValue(new_value) => {

            updated_value = component_state.set_value(&core.component_states, new_value);
        }

    };

    log_debug!("Updated {} to {:?}", component_state, updated_value);

    return updated_value;
}

fn resolve_slice(
    core: &DoenetCore,
    component_state_slice: ComponentStateSlice,
) -> Vec<Option<StateVarValue>> {
    match &component_state_slice.1 {
        StateVarSlice::Single(_) => {
            let component_state = component_state_slice.index(StateIndex::Basic);
            vec![resolve_state_variable(core, &component_state)]
        }
        StateVarSlice::Array(_) => {
            // resolve the size before the elements
            let size_variable = component_state_slice.clone().index(StateIndex::SizeOf);
            let size_value: usize = resolve_state_variable(core, &size_variable)
            .expect("Array size should always resolve to a StateVarValue")
            .try_into().unwrap();
            
            indices_for_size(size_value).map(|id| {
                let element_variable = component_state_slice.clone().index(StateIndex::Element(id));
                resolve_state_variable(core, &element_variable)
            }).collect()
        }
    }
}

/// This determines the state var given its dependency values.
fn generate_update_instruction_for_state_ref(
    component_state: &ComponentState,
    dependency_values: HashMap<InstructionName, Vec<DependencyValue>>

) -> Result<StateVarUpdateInstruction<StateVarValue>, String> {

    if component_state.1.name() == PROP_INDEX_SV {
        prop_index_determine_value(dependency_values).map(|update_instruction| match update_instruction {
            StateVarUpdateInstruction::NoChange => StateVarUpdateInstruction::NoChange,
            StateVarUpdateInstruction::SetValue(num_val) => StateVarUpdateInstruction::SetValue(num_val.into()),
        })
    } else {

        let state_var_def = &component_state.0.node.definition
            .state_var_definitions.get(component_state.1.name()).unwrap();

        match component_state.1 {
            StateRef::Basic(_) => {
                state_var_def.determine_state_var_from_dependencies(dependency_values)
            },
            StateRef::SizeOf(_) => {
                state_var_def.determine_size_from_dependencies(dependency_values)
            },
            StateRef::ArrayElement(_, id) => {
                let internal_id = id - 1;
                state_var_def.determine_element_from_dependencies(internal_id, dependency_values)
            }
        }    
    }

}

fn get_dependency_values_for_state_var_slice(
    core: &DoenetCore,
    sv_slice: &ComponentStateSlice,
) -> Vec<DependencyValue> {

    let source = DependencySource::StateVar {
        component_type: &sv_slice.0.node.definition.component_type,
        state_var_name: sv_slice.1.name()
    };

    resolve_slice(core, sv_slice.clone())
        .into_iter()
        .filter_map(|v_opt|
            v_opt.map(|value| DependencyValue {
                source: source.clone(),
                value,
            })
        ).collect()
}

/// Instance independent state
#[derive(Debug, Clone)]
struct ComponentStateAllInstances<'a> (&'a ComponentNode, StateRef);

/// Similar to DependencyKey since they do not change per instance
#[derive(Debug, Clone)]
struct ComponentStateSliceAllInstances<'a> (&'a ComponentNode, StateVarSlice);

// TODO: Use &Dependency instead of cloning
fn dependencies_of_state_var<'a>(
    dependencies: &'a HashMap<DependencyKey, Vec<Dependency>>,
    component_state: &ComponentStateAllInstances,
) -> HashMap<InstructionName, Vec<&'a Dependency>> {
    let component_name = &component_state.0;
    let state_ref = &component_state.1;

    let deps = dependencies.iter().filter_map(| (key, deps) | {

        let key_is_me = key.0 == component_name.name && (
            key.1 == StateVarSlice::Single(state_ref.clone())
            || matches!(state_ref, StateRef::ArrayElement(_, _))
            && key.1 == StateVarSlice::Array(state_ref.name())
        );

        key_is_me.then(|| (key.2, deps))
    });

    let mut combined: HashMap<InstructionName, Vec<&Dependency>> = HashMap::new();
    for (k, v) in deps {
        if let Some(accum) = combined.get_mut(k) {
            let dedup: Vec<&Dependency> = v.iter().filter(|&x| !contains_ptr(accum, &x)).collect();
            accum.extend(dedup);
        } else {
            combined.insert(k, v.iter().collect());
        }
    }
    
    combined
}

fn contains_ptr<T>(v: &Vec<&T>, e: &T) -> bool {
    v.iter().any(|&x| std::ptr::eq(x, e))
}

fn get_source_for_dependency(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    dependency: &Dependency,
) -> DependencySource {

    match dependency {
        Dependency::Essential { component, origin } => {

                let data = essential_data.get(&component.name).unwrap().get(origin).unwrap();

                DependencySource::Essential {
                    value_type: data.get_type_as_str()
                }

        },

        Dependency::StateVarArrayCorrespondingElement { array_state } => {
            let component_type = array_state.0
                .component_definition(component_nodes)
                .component_type;

            DependencySource::StateVar {
                component_type,
                state_var_name: array_state.1,
            }
        }
        Dependency::StateVar { states } => {
            let component_type = states.0
                .definition_member(component_nodes)
                .component_type;

            DependencySource::StateVar {
                component_type,
                state_var_name: states.1.name()
            }
        },
        Dependency::UndeterminedChildren { .. } => {
            DependencySource::StateVar {
                component_type: "undetermined",
                state_var_name: "undetermined",
            }
        },
        Dependency::MapSources { map_sources, state_var_slice } => {
            let component_type = ComponentGroupRelative::Collection(map_sources.clone())
                .definition_member(component_nodes)
                .component_type;

            DependencySource::StateVar {
                component_type,
                state_var_name: state_var_slice.name()
            }
        },

        Dependency::StateVarArrayDynamicElement { array_state, .. } => {
            let component_type = array_state.0
                .component_definition(component_nodes)
                .component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: &array_state.1
            }
        }

    }
}

/// Also includes the values of essential data
fn get_dependency_sources_for_state_var(
    core: &DoenetCore,
    component_state: &ComponentState,
) -> HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> {

    let map = &component_state.0.instance;
    let state_ref = &component_state.1;
    
    let my_dependencies = dependencies_of_state_var(&core.dependencies, &component_state.clone().ignore_instance());
    let mut dependency_sources: HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> = HashMap::new();

    for (instruction_name, dependencies) in my_dependencies {
        let instruction_sources: Vec<(DependencySource, Option<StateVarValue>)> = dependencies.iter().map(|dependency| {
            let source = get_source_for_dependency(&core.component_nodes, &core.essential_data, &dependency);

            let essential_value = if let Dependency::Essential { origin, .. } = dependency {
                let data = core.essential_data
                    .get(&component_state.0.node.name).unwrap()
                    .get(origin).unwrap();
                let value = data.get_value(state_ref.index(), map).unwrap();
                Some(value)

            } else {
                None
            };

            (source, essential_value)
        }).collect();

        dependency_sources.insert(instruction_name, instruction_sources);
    }

    dependency_sources
}

#[derive(Debug, Clone)]
enum ObjectStateVarInstance<'a> {
    String(String),
    Component(ComponentStateSlice<'a>),
}

fn state_vars_for_undetermined_children<'a>(
    core: &'a DoenetCore,
    component_ref: ComponentRef<'a>,
    desired_profiles: &'a Vec<ComponentProfile>,
) -> Vec<(ObjectStateVarInstance<'a>, DependencySource)> {
    let mut source_and_value = vec![];

    for (member_child, _) in get_child_refs_including_copy_and_members(core, component_ref) {
        match member_child {
            ObjectRef::Component(child_ref_instance) => {

                let child_def = child_ref_instance.component_definition();

                match  &child_def.replacement_components {
                    Some(ReplacementComponents::Children) => {
                        source_and_value.extend(state_vars_for_undetermined_children(core, child_ref_instance, desired_profiles));
                        continue;
                    }
                    _ => (),
                };
                        
                if let Some(relevant_sv) = child_def.component_profile_match(&desired_profiles) {
                    let comp_ref_slice = ComponentRefStateSlice(child_ref_instance, relevant_sv);
                    let sv_slice = comp_ref_slice.convert_to_state_slice(core).unwrap();

                    let dependency_source = DependencySource::StateVar {
                        component_type: child_def.component_type,
                        state_var_name: sv_slice.1.name()
                    };
                    source_and_value.push((ObjectStateVarInstance::Component(sv_slice), dependency_source));
                }
            },
            ObjectRef::String(s) => {
                let dependency_source = DependencySource::StateVar {
                    component_type: "string",
                    state_var_name: "",
                };
                source_and_value.push((ObjectStateVarInstance::String(s), dependency_source));
            },
        };
    }
    source_and_value
}

/// Find the component that the sources dependency points to
fn map_sources_dependency_member<'a>(
    core: &'a DoenetCore,
    component_instance: &ComponentInstance,
    sources: &'a ComponentRelative,
) -> ComponentRef<'a> {
    let sources_instance = sources.relative_instance.relative_to(&component_instance.instance);
    let collection_index = *component_instance.instance.get(sources_instance.len()).unwrap();
    let component_instance = ComponentInstance {
        node: &core.component_nodes.get(&sources.name).unwrap(),
        instance: sources_instance,
    };
    ComponentRef::CollectionMember(component_instance, collection_index)
}






fn mark_stale_state_var_and_dependencies(
    core: &DoenetCore,
    states: &ComponentInstancesStateSlice,
) {
    let state = states.ignore_instance().get_state_var_state_var(core);
    let instances = state.instances_where_slice_is_resolved(&states.1, &states.0.instance_group);

    // log_debug!("Check stale {:?}", states);
    for instance in instances {

        let instance = instance.expect(&format!("Error accessing state of {:?}", states));
        let component_state_slice = states.specify_instance(instance);
        log_debug!("Marking stale {}", component_state_slice);

        state.mark_stale_slice(&component_state_slice.1, &component_state_slice.0.instance);

        let depending_on_me = get_state_variables_depending_on_me(core, &component_state_slice);

        for component_instances_slice in depending_on_me {
            mark_stale_state_var_and_dependencies(core, &component_instances_slice);
        }
    }
}

fn mark_stale_essential_datum_dependencies(
    core: &DoenetCore,
    essential_state: &EssentialState,
) {
    let component = ComponentRelative::same_instance(essential_state.0.node.name.clone());
    let map = &essential_state.0.instance;
    let origin = essential_state.1.clone();
    let state_index = &essential_state.2;

    // log_debug!("Marking stale essential {}:{}", component_name, state_var);

    let search_dep = Dependency::Essential {
        component,
        origin,
    };

    let my_dependencies = core.dependencies.iter().filter_map( |(key, deps) | {
        if deps.contains(&search_dep) {
            let state_ref_option = match &key.1 {
                StateVarSlice::Single(s) => Some(s.clone()),
                StateVarSlice::Array(_) => key.1.clone().specify_index(state_index.clone())
            };
            state_ref_option.map (|state_var_ref|
                ComponentInstancesStateSlice(ComponentInstances {
                    node: core.component_nodes.get(&key.0).unwrap(),
                    instance_group: map.clone(),
                }, StateVarSlice::Single(state_var_ref))
            )
        } else {
            None
        }
    });

    for component_instances_slice  in my_dependencies {
        mark_stale_state_var_and_dependencies(core, &component_instances_slice);
    }
}

/// Calculate all the state vars that depend on the given state var
fn get_state_variables_depending_on_me<'a>(
    core: &'a DoenetCore,
    component_states: &'a ComponentStateSlice,
) -> Vec<ComponentInstancesStateSlice<'a>> {

    let sv_component = &component_states.0.node;
    let sv_slice = &component_states.1;

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {
        for dependency in dependencies {

            let mut add_dependent: Option<(RelativeInstance, &StateVarSlice)> = None;
            match dependency {
                Dependency::StateVar { states } => {
                    let slice_depends = match &states.0 {
                        ComponentGroupRelative::Single(ComponentRefRelative::Component(BatchMemberRel(n, b, i))) => {
                            let component_state_slice = ComponentStateSliceAllInstances(core.component_nodes.get(&n.name).unwrap(), states.1.clone());
                            let state_var_slice = batch_state_var(&component_state_slice, *b, *i).unwrap();
                            slice_depends_on_slice(&state_var_slice, sv_slice)
                        },
                        ComponentGroupRelative::Batch(n) => {
                            let component_state_slice = ComponentStateSliceAllInstances(core.component_nodes.get(&n.name).unwrap(), states.1.clone());
                            // TODO: check if any index depends on sv_slice, not just some range
                            (1..4).filter_map(|i| batch_state_var(&component_state_slice, None, i))
                                .any(|s| slice_depends_on_slice(&s, sv_slice))
                        },
                        _ => slice_depends_on_slice(&states.1, sv_slice),
                    };

                    if group_includes_component(&core.collection_members, &states.0, sv_component)
                    && slice_depends {
                        add_dependent = Some((
                            states.0.of_node_relative().relative_instance.clone(),
                            &dependency_key.1,
                        ));
                    }
                },

                Dependency::UndeterminedChildren { component, desired_profiles } => {
                    let sv_component_def = sv_component.definition;
                    let depends =
                        if collection_may_contain(&core.collection_members.get(&component.name).unwrap(), sv_component) {
                            true
                        } else if sv_component_def.component_profile_match(desired_profiles).is_some() {
                            let component_node = core.component_nodes.get(&component.name).unwrap();
                            let mut chain = parent_chain(&core.component_nodes, component_node);
                            let parent = chain.find(|p| {
                                !matches!(p.definition.replacement_components, Some(ReplacementComponents::Children))
                            });
                            parent.map(|p| std::ptr::eq(p, component_node)).unwrap_or(false)
                        } else {
                            false
                        };
                    if depends {
                        add_dependent = Some((
                            component.relative_instance.clone(),
                            &dependency_key.1,
                        ));
                    }
                },

                Dependency::MapSources { map_sources, state_var_slice } => {
                    if sv_component.name == *map_sources.name
                    && slice_depends_on_slice(state_var_slice, sv_slice) {
                        add_dependent = Some((
                            RelativeInstance::default(),
                            &dependency_key.1,
                        ));
                    }
                },

                Dependency::StateVarArrayCorrespondingElement { array_state } => {
                    if group_includes_component(&core.collection_members, &ComponentGroupRelative::Single(array_state.0.clone()), sv_component)
                    && array_state.1 == sv_slice.name() {
                        add_dependent = Some((
                            array_state.0.of_node_relative().relative_instance.clone(),
                            &sv_slice,
                        ));
                    }
                },

                Dependency::StateVarArrayDynamicElement { array_state, .. } => {

                    let this_array_refers_to_me = 
                        group_includes_component(&core.collection_members, &ComponentGroupRelative::Single(array_state.0.clone()), sv_component)
                        && array_state.1 == sv_slice.name();

                    let i_am_prop_index_of_this_dependency = 
                        // The key that this dependency is under is myself
                        // Aka, the index is supposed to be in my component, not another component
                        dependency_key.0 == *sv_component.name
                        // I am actually a propIndex, and not some other state var
                        && sv_slice == &StateVarSlice::Single(StateRef::Basic("propIndex"));

                    if this_array_refers_to_me || i_am_prop_index_of_this_dependency {
                        add_dependent = Some((
                            array_state.0.of_node_relative().relative_instance.clone(),
                            &dependency_key.1,
                        ));
                    }
                },

                // Essential dependencies are endpoints
                Dependency::Essential { .. } => {},

            }
            if let Some((relative_instance, slice)) = add_dependent {
                let dependency_component = &core.component_nodes.get(&dependency_key.0).unwrap();
                let instance_group = relative_instance.relative_to_inverse(&component_states.0.instance);
                let instance_group = ComponentInstances {
                    node: dependency_component,
                    instance_group,
                };
                depending_on_me.push(ComponentInstancesStateSlice(instance_group, slice.clone()));
            }
        }
    }

    fn group_includes_component(
        collections: &HashMap<ComponentName, Vec<CollectionMembers>>,
        group: &ComponentGroupRelative,
        component: &ComponentNode,
    ) -> bool {
        match group {
            ComponentGroupRelative::Batch(n) |
            ComponentGroupRelative::Single(ComponentRefRelative::Component(NodeRel(n))) |
            ComponentGroupRelative::Single(ComponentRefRelative::Component(BatchMemberRel(n, _, _))) =>
                n.name == component.name,
            ComponentGroupRelative::Single(ComponentRefRelative::CollectionMember(n, _)) |
            ComponentGroupRelative::Collection(n) =>
                collection_may_contain(collections.get(&n.name).unwrap(), component)
        }
    }

    fn slice_depends_on_slice(a: &StateVarSlice, b: &StateVarSlice) -> bool {
        use StateVarSlice::*;
       a.name() == b.name()
       && match (a,b) {
           (Array(_), _) |
           (_, Array(_)) |
           (_, Single(StateRef::SizeOf(_))) |
           (Single(StateRef::Basic(_)), Single(StateRef::Basic(_))) =>
                true,
           (Single(StateRef::ArrayElement(i, _)), Single(StateRef::ArrayElement(j, _))) =>
               i == j,
           (_, _) => false
       }
    }

    depending_on_me
}

/// When referring to multiple instances, the vector is shorter than the number of maps
/// instancing the component. This is used to refer to every instance across the omitted maps.
pub type InstanceGroup = Vec<usize>;

#[derive(Debug, Clone)]
struct ComponentInstances<'a> {
    node: &'a ComponentNode,
    instance_group: InstanceGroup
}

/// Used to mark stale in bulk
#[derive(Debug, Clone)]
struct ComponentInstancesStateSlice<'a> (ComponentInstances<'a>, StateVarSlice);

impl ComponentInstancesStateSlice<'_> {
    fn specify_instance(&self, instance: Instance) -> ComponentStateSlice {
        let component_instance = ComponentInstance {
            node: self.0.node,
            instance,
        };
        ComponentStateSlice(component_instance, self.1.clone())
    }
    fn ignore_instance(&self) -> ComponentStateSliceAllInstances {
        ComponentStateSliceAllInstances(self.0.node, self.1.clone())
    }
}

impl ComponentStateSliceAllInstances<'_> {
    fn get_state_var_state_var<'a>(&self, core: &'a DoenetCore) -> &'a StateForStateVar {
        core.component_states
            .get(&self.0.name).unwrap()
            .get(&self.1.name()).unwrap()
    }
}






pub fn update_renderers(core: &DoenetCore) -> String {
    let json_obj = generate_render_tree(core);

    log_json!("Component tree after renderer update", utils::json_components(&core.component_nodes, &core.component_states));

    log_json!("Essential data after renderer update",
    utils::json_essential_data(&core.essential_data));

    serde_json::to_string(&json_obj).unwrap()
}

fn generate_render_tree(core: &DoenetCore) -> serde_json::Value {

    let root_node = core.component_nodes.get(&core.root_component_name).unwrap();
    let component_instance = ComponentInstance {
        node: root_node,
        instance: Instance::default(),
    };
    let root_comp_rendered = RenderedComponent {
        component_ref: ComponentRef::Component(Node(component_instance)),
        child_of_copy: None
    };
    let mut json_obj: Vec<serde_json::Value> = vec![];

    log!("===== Render tree ======");
    generate_render_tree_internal(core, root_comp_rendered, &mut json_obj);

    serde_json::Value::Array(json_obj)
}

fn generate_render_tree_internal(
    core: &DoenetCore,
    component: RenderedComponent,
    json_obj: &mut Vec<serde_json::Value>,
) {
    use serde_json::{Map, Value, json};

    log_debug!("generating render tree for {}", component);

    let component_definition = component.component_ref
        .component_definition();

    let renderered_state_vars = component_definition
        .state_var_definitions
        .into_iter()
        .filter_map(|(k, v)| {
            v.for_renderer().then(|| match v.is_array() {
                true => StateVarSlice::Array(k),
                false => StateVarSlice::Single(StateRef::Basic(k)),
            })
        });

    let state_var_aliases = match &component_definition.renderer_type {
        RendererType::Special { state_var_aliases, .. } => state_var_aliases.clone(),
        RendererType::Myself => HashMap::new(),
    };

    let mut state_values = serde_json::Map::new();
    for state_var_slice in renderered_state_vars {
        let comp_ref_slice = ComponentRefStateSlice(component.component_ref.clone(), state_var_slice);
        let sv_slice = comp_ref_slice.convert_to_state_slice(core).unwrap();

        let sv_renderer_name = state_var_aliases
            .get(&sv_slice.1.name())
            .map(|x| *x)
            .unwrap_or(sv_slice.1.name())
            .to_string();

        let values = resolve_slice(core, sv_slice.clone());

        let mut json_value = match sv_slice.1 {
            StateVarSlice::Array(_) => json!(values),
            StateVarSlice::Single(_) => json!(values.first().unwrap()),
        };

        // hardcoded exceptions
        if sv_renderer_name == "numericalPoints"
        && matches!(sv_slice.1, StateVarSlice::Array(_)) {
            let array_2d =
                [[values.get(0).unwrap(), values.get(1).unwrap()],
                [values.get(2).unwrap(), values.get(3).unwrap()]];
            json_value = json!(array_2d)
        }
        if sv_renderer_name == "selectedStyle" {
            let string: String = values.get(0).unwrap().clone().unwrap().try_into().unwrap();
            json_value = serde_json::from_str(&string).unwrap();
        }

        state_values.insert(sv_renderer_name, json_value);
    }

    let name_to_render = name_rendered_component(&component, component_definition.component_type);

    let mut children_instructions = Vec::new();
    if component_definition.should_render_children {
        for (child, actual_parent) in get_child_refs_including_copy_and_members(core, component.component_ref.clone()) {
            match child {
                ObjectRef::String(string) => {
                    children_instructions.push(json!(string));
                },
                ObjectRef::Component(comp_ref_instance) => {
                    let child_component = RenderedComponent {
                        component_ref: comp_ref_instance,
                        child_of_copy: component.child_of_copy.clone().or(
                            (actual_parent != component.component_ref).then(|| component.component_ref.clone())
                        ),
                    };

                    let child_definition = child_component.component_ref
                        .component_definition();

                    let child_name = name_rendered_component(&child_component, child_definition.component_type);

                    let action_component_name = child_component.component_ref.clone()
                        .convert_to_node_instance(core)
                        .map(|x| x.alias())
                        .unwrap_or(child_component.component_ref.of_node().node.name.clone());

                    let child_actions: Map<String, Value> =
                        (child_definition.action_names)()
                        .iter()
                        .map(|action_name| (action_name.to_string(), json!({
                            "actionName": action_name,
                            "componentName": action_component_name,
                        }))).collect();

                    let renderer_type = match &child_definition.renderer_type {
                        RendererType::Special{ component_type, .. } => *component_type,
                        RendererType::Myself => child_definition.component_type,
                    };

                    children_instructions.push(json!({
                        "actions": child_actions,
                        "componentName": child_name,
                        "componentType": child_definition.component_type,
                        "effectiveName": child_name,
                        "rendererType": renderer_type,
                    }));

                    generate_render_tree_internal(core, child_component, json_obj); 
                },
            }
        }
    }

    json_obj.push(json!({
        "componentName": name_to_render,
        "stateValues": serde_json::Value::Object(state_values),
        "childrenInstructions": json!(children_instructions),
    }));

}

fn name_rendered_component(component: &RenderedComponent, component_type: &str) -> String {
    let name_to_render = match &component.component_ref {
        ComponentRef::CollectionMember(n, i) |
        ComponentRef::Component(BatchMember(n, _, i)) =>
            format!("__{}_from_({}[{}])", component_type, n.node.name, *i),
        ComponentRef::Component(Node(n)) => n.node.name.clone(),
    };
    let name_to_render = match &component.child_of_copy {
        Some(copy_name) => format!("__cp:{}({})", name_to_render, copy_name),
        None => name_to_render,
    };
    let name_to_render = if component.component_ref.instance().is_empty() {
            name_to_render
        } else {
            format!("__{}_map{:?}", name_to_render, component.component_ref.instance())
        };
    name_to_render
}




#[derive(Debug)]
pub struct Action {
    pub component_name: ComponentName,
    pub action_name: String,

    /// The keys are not state variable names.
    /// They are whatever name the renderer calls the new value.
    pub args: HashMap<String, Vec<StateVarValue>>,
}

/// Internal structure used to track changes
#[derive(Debug, Clone)]
enum UpdateRequest<'a> {
    SetEssentialValue(EssentialState<'a>, StateVarValue),
    SetStateVar(ComponentState<'a>, StateVarValue),
}

pub fn handle_action_from_json(core: &DoenetCore, action: &str) -> String {

    let (action, action_id) = parse_json::parse_action_from_json(action)
        .expect(&format!("Error parsing json action: {}", action));

    handle_action(core, action);

    action_id
}

pub fn handle_action(core: &DoenetCore, action: Action) {

    log_debug!("Handling action {:#?}", action);

    let component_instance  = ComponentInstance::dealias(&core.component_nodes, &action.component_name);

    let component = component_instance.node;

    let state_var_resolver = | state_var_ref: &StateRef | {
        let component_state = ComponentState(component_instance.clone(), state_var_ref.clone());
        resolve_state_variable(core, &component_state)
    };

    let state_vars_to_update = (component.definition.on_action)(
        &action.action_name,
        action.args,
        &state_var_resolver,
    );

    for (state_var_ref, requested_value) in state_vars_to_update {

        let component_state = ComponentState(component_instance.clone(), state_var_ref.clone());
        let request = UpdateRequest::SetStateVar(component_state, requested_value);
        process_update_request(core, &request);
    }

    // log_json!("Component tree after action", utils::json_components(&core.component_nodes, &core.component_states));
}


/// Convert the results of `request_dependencies_to_update_value`
/// into UpdateRequest struct.
fn convert_dependency_values_to_update_request<'a>(
    core: &'a DoenetCore,
    component_state: &'a ComponentState,
    requests: HashMap<InstructionName, Result<Vec<DependencyValue>, String>>,
) -> Vec<UpdateRequest<'a>> {

    let component = component_state.0.node;
    let state_var = &component_state.1;

    let my_dependencies = dependencies_of_state_var(&core.dependencies, &component_state.clone().ignore_instance());

    let mut update_requests = Vec::new();

    for (instruction_name, instruction_requests) in requests {

        let valid_requests = match instruction_requests {
            Err(_e) => {
                log_debug!("Inverse definition for {} failed with: {}", component_state, _e);
                break;
            },
            Ok(result) => result,
        };

        // stores (group name, index)
        let mut group_index = (None, 0);
        let increment = |group_index: (Option<ComponentName>, usize), n: &ComponentName| {
            if group_index.0 == Some(n.clone()) {
                (Some(n.clone()), group_index.1 + 1)
            } else {
                (Some(n.clone()), 1)
            }
        };


        let instruct_dependencies = my_dependencies.get(instruction_name).expect(
            &format!("{}:{} has the wrong instruction name to determine dependencies",
                component.definition.component_type, state_var)
        );

        assert_eq!(valid_requests.len(), instruct_dependencies.len());

        for (request, dependency) in valid_requests.into_iter().zip(instruct_dependencies.iter()) {

            match dependency {
                Dependency::Essential { component, origin } => {
                    let component_instance = component.instance_relative_to(&core.component_nodes, &component_state.0);
                    update_requests.push(UpdateRequest::SetEssentialValue(
                        EssentialState(component_instance, origin.clone(), state_var.index()),
                        request.value.clone(),
                    ))
                },
                Dependency::StateVar { states } => {
                    // TODO: recieving multiple dependencies because of multiple instances
                    let component_ref = match &states.0 {
                        ComponentGroupRelative::Batch(n) => {
                            group_index = increment(group_index, &n.name);
                            ComponentRefRelative::Component(BatchMemberRel(n.clone(), None, group_index.1 - 1))
                        },
                        ComponentGroupRelative::Collection(n) => {
                            group_index = increment(group_index, &n.name);
                            ComponentRefRelative::CollectionMember(n.clone(), group_index.1 - 1)
                        },
                        ComponentGroupRelative::Single(comp_ref) => {
                            comp_ref.clone()
                        },
                    };

                    let component_ref = component_ref.replace_instance(&core.component_nodes, component_state.0.instance.clone());
                    let comp_ref_slice = ComponentRefStateSlice(component_ref, states.1.clone());
                    if let Some(sv_slice) = comp_ref_slice.convert_to_state_slice(core) {
                        if let StateVarSlice::Single(state_var_ref) = sv_slice.1 {
                            let component_state = ComponentState(sv_slice.0, state_var_ref);
                            update_requests.push(UpdateRequest::SetStateVar(component_state, request.value.clone()))
                        }
                    }
                },
                _ => (),
            }
        }

    }

    update_requests

}

fn process_update_request(
    core: &DoenetCore,
    update_request: &UpdateRequest
) {

    log_debug!("Processing update request {:?}", update_request);

    match update_request {
        UpdateRequest::SetEssentialValue(essential_state, requested_value) => {

            let essential_var = core.essential_data
                .get(&essential_state.0.node.name).unwrap()
                .get(&essential_state.1).unwrap();

            essential_var.set_value(
                    essential_state.2.clone(),
                    requested_value.clone(),
                    &essential_state.0.instance,
                ).expect(
                    &format!("Failed to set essential value for {:?}", essential_state)
                );

            // log_debug!("Updated essential data {:?}", core.essential_data);

            mark_stale_essential_datum_dependencies(core, essential_state);
        },

        UpdateRequest::SetStateVar(component_state, requested_value) => {

            let dep_update_requests = request_dependencies_to_update_value_including_shadow(
                core,
                component_state,
                requested_value.clone(),
            );

            for dep_update_request in dep_update_requests {
                process_update_request(core, &dep_update_request);
            }

            // needed?
            // mark_stale_state_var_and_dependencies(core, component_name, &map, &StateVarSlice::Single(state_var_ref.clone()));
        }
    }
}

fn request_dependencies_to_update_value_including_shadow<'a>(
    core: &'a DoenetCore,
    component_state: &'a ComponentState,
    new_value: StateVarValue,
) -> Vec<UpdateRequest<'a>> {

    let component = component_state.0.node;
    let state_var_ref = &component_state.1;

    if let Some(component_ref_slice_relative) = state_var_is_shadowing(&component_state.clone().ignore_instance()) {

        let component_instance = component_ref_slice_relative.0.instance_relative_to(&core.component_nodes, &component_state.0);
        let source_ref_slice = ComponentRefStateSlice(component_instance, component_ref_slice_relative.1);
        let source_state =
            source_ref_slice.convert_to_state_slice(core)
            .unwrap();
        let source_state = match source_state.1 {
            StateVarSlice::Single(state_ref) => ComponentState(source_state.0, state_ref),
            StateVarSlice::Array(_) => panic!(),
        };
        vec![UpdateRequest::SetStateVar(source_state, new_value)]

    } else {

        let dependency_sources = get_dependency_sources_for_state_var(core, component_state);

        log_debug!("Dependency sources for {}, {:?}", component_state, dependency_sources);

        let requests = component.definition.state_var_definitions.get(state_var_ref.name()).unwrap()
            .request_dependencies_to_update_value(state_var_ref, new_value, dependency_sources)
            .expect(&format!("Failed requesting dependencies for {}", component_state));

        log_debug!("{} wants its dependency to update to: {:?}", component_state, requests);

        let update_requests = convert_dependency_values_to_update_request(core, component_state, requests);

        log_debug!("{} generated update requests: {:#?}", component_state, update_requests);

        update_requests
    }
}

/// Detect if a state var is shadowing because of a CopySource
/// and has a primary input state variable, which is needed.
fn state_var_is_shadowing<'a>(component_state: &'a ComponentStateAllInstances)
    -> Option<ComponentRefStateSliceRelative> {

    let component = component_state.0;
    let state_var = &component_state.1;
    if let Some(CopySource::StateVar(ref component_relative)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {
                Some(ComponentRefStateSliceRelative::new(component_relative.0.clone(), StateVarSlice::Single(component_relative.1.clone())))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.definition.component_type);
        }

    } else if let Some(CopySource::DynamicElement(ref source_comp, ..)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {

                Some(ComponentRefStateSliceRelative::new(source_comp.0.clone(), StateVarSlice::Array(source_comp.1.clone())))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.definition.component_type);
        }


    } else {
        None
    }
}





#[derive(Debug)]
enum ObjectRef<'a> {
    Component(ComponentRef<'a>),
    String(String),
}

fn get_child_refs_including_copy_and_members<'a>(
    core: &'a DoenetCore,
    component_ref: ComponentRef<'a>,
) -> Vec<(ObjectRef<'a>, ComponentRef<'a>)> {

    let mut children_vec: Vec<(ObjectRef, ComponentRef)> = Vec::new();
    let component = component_ref.clone().convert_to_node_instance(core);
    if component.is_none() {
        return vec![]
    }
    let component_instance = component.unwrap();
    let component = component_instance.node;
    match &component.copy_source {
        Some(CopySource::Component(component_ref_relative)) => {
            let copy_ref_instance = component_ref_relative.instance_relative_to(&core.component_nodes, &component_instance);
            children_vec = get_child_refs_including_copy_and_members(core, copy_ref_instance);
        },
        Some(CopySource::MapSources(map_sources)) => {
            let source_instance = map_sources_dependency_member(core, &component_instance, map_sources);
            children_vec = get_child_refs_including_copy_and_members(core, source_instance);
        },
        _ => {},
    }

    let use_map = &component_instance.instance;
    children_vec.extend(
        component.children
        .iter()
        .flat_map(|c| match c {
            ComponentChild::String(s) => vec![(ObjectRef::String(s.clone()), component_ref.clone())],
            ComponentChild::Component(c) => {
                let node = ComponentInstance {
                    node: core.component_nodes.get(c).unwrap(),
                    instance: use_map.clone(),
                };
                match &core.component_nodes.get(c).unwrap().definition.replacement_components {
                    Some(ReplacementComponents::Batch(_)) => {
                        ComponentGroup::Batch(node)
                        .group_members(core).iter().map(|comp_ref|
                            (ObjectRef::Component(comp_ref.clone()),
                            component_ref.clone())
                        ).collect::<Vec<(ObjectRef, ComponentRef)>>()
                    },
                    Some(ReplacementComponents::Collection(_)) => {
                        ComponentGroup::Collection(node)
                        .group_members(core).iter().map(|comp_ref|
                            (ObjectRef::Component(comp_ref.clone()),
                            component_ref.clone())
                        ).collect::<Vec<(ObjectRef, ComponentRef)>>()
                    },
                    _ => {
                        vec![(ObjectRef::Component(ComponentRef::Component(Node(node))),
                        component_ref.clone())]
                    }
                }
            }
        })
    );

    children_vec
}

fn get_child_nodes_including_copy<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> Vec<(&'a ComponentChild, &'a ComponentNode)> {

    let mut children_vec: Vec<(&ComponentChild, &ComponentNode)> = Vec::new();
    if let Some(CopySource::Component(ComponentRefRelative::Component(NodeRel(ref source)), ..)) = component.copy_source {

        let source_comp = components.get(&source.name).unwrap();

        children_vec = get_child_nodes_including_copy(components, source_comp);
    }

    children_vec.extend(
        component.children
        .iter()
        .map(|c| (c, component))
    );

    children_vec
}



// ==== Type Implementations ====

impl<'a> ComponentGenerated<'a> {
    fn try_into_node(self) -> Option<ComponentInstance<'a>> {
        match self {
            Node(n) => Some(n),
            BatchMember(_,_,_) => None,
        }
    }

    fn generated_by(&self) -> ComponentInstance {
        match self {
            Node(name) |
            BatchMember(name,_,_) => name.clone(),
        }
    }
}

impl<'a> ComponentRef<'a> {
    fn component_definition(&self) -> &'static ComponentDefinition {
        let node = self.of_node().node;
        match self {
            ComponentRef::CollectionMember(_, _) =>
                (node.definition.unwrap_collection_def().member_definition)(&node.static_attributes),
            ComponentRef::Component(BatchMember(_, n, _)) =>
                node.definition.unwrap_batch_def(n).member_definition,
            ComponentRef::Component(Node(_)) => node.definition,
        }
    }

    fn of_node(&self) -> ComponentInstance {
        match self {
            Self::Component(node_or_batch) => node_or_batch.generated_by(),
            Self::CollectionMember(name, _) => name.clone(),
        }
    }

    fn instance(&self) -> Instance {
        match self {
            ComponentRef::Component(Node(n)) |
            ComponentRef::Component(BatchMember(n, _, _)) |
            ComponentRef::CollectionMember(n, _) => n.instance.clone()
        }
    }
}

impl<'a> ComponentState<'a> {
    fn ignore_instance(self) -> ComponentStateAllInstances<'a> {
        ComponentStateAllInstances(self.0.node, self.1)
    }
    fn replace_index(&self, index: StateIndex) -> Self {
        ComponentState(self.0.clone(), StateRef::from_name_and_index(self.1.name(), index))
    }
    fn replace_state_var(self, state_ref: StateRef) -> Self {
        ComponentState(self.0, state_ref)
    }

    fn get_value(&self, component_states: &HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>)
        -> Option<State<StateVarValue>> {
        component_states.get(&self.0.node.name).unwrap()
            .get(&self.1.name())
            .expect(&format!("Component {} has no state var '{}'", self.0.node.name, self.1))
            .get_single_state(&self.1.index(), &self.0.instance)
            .expect(&format!("Error accessing state of {}", self))
    }

    fn set_value(&self, component_states: &HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>, new_value: StateVarValue)
        -> Option<StateVarValue> {
            component_states.get(&self.0.node.name).unwrap()
                .get(&self.1.name())
                .expect(&format!("Component {} has no state var '{}'", self.0.node.name, self.1))
                .set_single_state(&self.1.index(), new_value, &self.0.instance)
                .unwrap()
    }
}

impl<'a> ComponentStateSlice<'a> {
    fn index(self, index: StateIndex) -> ComponentState<'a> {
        match (&self.1, index) {
            (StateVarSlice::Single(n), StateIndex::Basic) => ComponentState(self.0, n.clone()),
            (_, StateIndex::Basic) |
            (StateVarSlice::Single(_), _) => panic!(),
            (StateVarSlice::Array(n), i) => ComponentState(self.0, StateRef::from_name_and_index(n,i)),
        }
    }
}

impl ComponentInstance<'_> {
    /// Used for action names
    fn alias(&self) -> String {
        if self.instance.is_empty() {
            self.node.name.clone()
        } else {
            format!("{:?}{}", self.instance, self.node.name)
        }
    }

    fn dealias<'a>(component_nodes: &'a HashMap<ComponentName, ComponentNode>, alias: &String) -> ComponentInstance<'a> {
        let chars: Vec<char> = alias.chars().collect();

        if chars[0] != '[' {
            return ComponentInstance {
                node: component_nodes.get(alias).unwrap(),
                instance: Instance::default(),
            };
        }

        let end_bracket = chars.iter().position(|&c| c == ']').unwrap();
        let map_chars: String = chars[1..end_bracket].iter().collect();
        let name: String = chars[end_bracket+1..].iter().collect();

        let instance: Instance = map_chars
            .split(", ")
            .map(|s| s.parse().unwrap() )
            .collect();
        ComponentInstance {
            node: component_nodes.get(&name).unwrap(),
            instance,
        }
    }
}

impl PartialEq for ComponentInstance<'_> {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self.node, other.node) && self.instance == other.instance
    }
}
impl Eq for ComponentInstance<'_> {}

impl ComponentRefStateArrayRelative {
    fn split_array_with_index(&self, index: StateIndex) -> (&ComponentRefRelative, StateVarSlice) {
        (&self.0, StateVarSlice::Single(StateRef::from_name_and_index(self.1, index)))
    }
}

impl ComponentRelative {
    fn same_instance(name: ComponentName) -> Self {
        ComponentRelative {
            name,
            relative_instance: RelativeInstance::default(),
        }
    }
}

impl ComponentRefStateSliceRelative {
    fn new(component_ref_relative: ComponentRefRelative, state_var: StateVarSlice) -> Self {
        ComponentRefStateSliceRelative(component_ref_relative, state_var)
    }
}

impl ComponentRefRelative {
    fn node(name: ComponentName) -> Self {
        ComponentRefRelative::Component(NodeRel(ComponentRelative::same_instance(name)))
    }
}

impl Display for ComponentInstance<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.instance.is_empty() {
            write!(f, "{}", self.node.name)
        } else {
            write!(f, "{}(instance {:?})", self.node.name, self.instance)
        }
    }
}
impl Display for ComponentRelative {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.relative_instance.is_empty() {
            write!(f, "{}", self.name)
        } else {
            write!(f, "{}(instance {:?})", self.name, self.relative_instance)
        }
    }
}

impl Display for ComponentState<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.0, self.1)
    }
}
impl Display for ComponentStateSlice<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.0, self.1)
    }
}

impl Display for ComponentStateSliceAllInstances<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.0.name, self.1)
    }
}

impl Display for ComponentGenerated<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Node(n) => write!(f, "{}", n),
            Self::BatchMember(n, None, i) => write!(f, "{}[{}]", n, i),
            Self::BatchMember(n, Some(c), i) => write!(f, "{}:{}[{}]", c, n, i)
        }
    }
}
impl Display for ComponentGeneratedRelative {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NodeRel(n) => write!(f, "{}", n),
            Self::BatchMemberRel(n, None, i) => write!(f, "{}[{}]", n, i),
            Self::BatchMemberRel(n, Some(c), i) => write!(f, "{}:{}[{}]", c, n, i)
        }
    }
}

impl Display for ComponentRef<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Component(n) => write!(f, "{}", n),
            Self::CollectionMember(n, i) => write!(f, "{}[{}]", n, i)
        }
    }
}
impl Display for ComponentRefRelative {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Component(n) => write!(f, "{}", n),
            Self::CollectionMember(n, i) => write!(f, "{}[{}]", n, i)
        }
    }
}

impl Display for RenderedComponent<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(child_of_copy) = &self.child_of_copy {
            write!(f, "{}(child of {})", self.component_ref, child_of_copy)
        } else {
            write!(f, "{}", self.component_ref)
        }
    }
}

impl Display for ComponentGroup<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ComponentGroup::Single(n) => write!(f, "{}", n),
            ComponentGroup::Batch(n) => write!(f, "{}(Batch)", n),
            ComponentGroup::Collection(n) => write!(f, "{}(Collection)", n),
        }
    }
}
impl Display for ComponentGroupRelative {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ComponentGroupRelative::Single(n) => write!(f, "{}", n),
            ComponentGroupRelative::Batch(n) => write!(f, "{}(Batch)", n),
            ComponentGroupRelative::Collection(n) => write!(f, "{}(Collection)", n),
        }
    }
}

impl Serialize for ComponentInstance<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer {
        serializer.serialize_str(&format!("{}", self))
    }
}

impl Serialize for GroupStateSliceRelative {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where S: serde::Serializer
    {
        serializer.serialize_str(&format!("{}:{}", self.0, self.1))
    }
}


// ==== Groups (Batches/Collections) ====

/// A group of ComponentRefs: A single ComponentRef or component's ReplacementChildren
#[derive(PartialEq, Serialize, Eq, Clone, Debug)]
pub enum ComponentGroup<'a> {
    Single(ComponentRef<'a>),
    /// A component whose replacement children is a collection
    Collection(ComponentInstance<'a>),
    /// A component whose replacement children is a batch
    Batch(ComponentInstance<'a>),
}

impl<'a> ComponentGroup<'a> {
    /// Converts component group to a vector of component references.
    /// - resolves the size of batches and collections
    fn group_members(self, core: &'a DoenetCore) -> Vec<ComponentRef<'a>> {
        match self {
            ComponentGroup::Single(comp_ref) => vec![comp_ref],
            ComponentGroup::Batch(name) =>
                indices_for_size(resolve_batch_size(core, &name, None))
                    .map(|i| ComponentRef::Component(BatchMember(name.clone(), None, i))).collect(),
            ComponentGroup::Collection(name) =>
                indices_for_size(collection_size(core, &name))
                    .map(|i| ComponentRef::CollectionMember(name.clone(), i)).collect(),
        }
    }
}

fn resolve_batch_size(
    core: &DoenetCore,
    component_instance: &ComponentInstance,
    batch_name: Option<BatchName>,
) -> usize {

    let batch_def = component_instance.node.definition.unwrap_batch_def(&batch_name);
    let size_variable = ComponentState(component_instance.clone(), batch_def.size.clone());
    resolve_state_variable(core, &size_variable)
        .unwrap().try_into().unwrap()
}

fn collection_size(
    core: &DoenetCore,
    component_instance: &ComponentInstance,
) -> usize {

    core.collection_members.get(&component_instance.node.name).unwrap()
        .iter()
        .map(|c| collection_members_size(core, &component_instance, c))
        .sum()
}

fn collection_members_size(
    core: &DoenetCore,
    map: &ComponentInstance,
    collection_members: &CollectionMembers,
) -> usize {
    match collection_members {
        CollectionMembers::Component(_) => 1,
        CollectionMembers::Batch(n) => resolve_batch_size(core, &n.instance_relative_to(&core.component_nodes, map), None),
        CollectionMembers::ComponentOnCondition { component, condition } => {
            let condition_variable = ComponentState(component.instance_relative_to(&core.component_nodes, map), condition.clone());
            match resolve_state_variable(core, &condition_variable) {
                Some(StateVarValue::Boolean(true)) => 1,
                _ => 0,
            }
        },
        CollectionMembers::InstanceBySources { sources, .. } => collection_size(core, &sources.instance_relative_to(&core.component_nodes, map)),
    }
}

/// Without resolving any state variables, answer whether it is possible that
/// the collection contains the component
fn collection_may_contain(members: &Vec<CollectionMembers>, component: &ComponentNode)
    -> bool {

    members.iter().any(|c|
        match c {
            CollectionMembers::ComponentOnCondition { component: n, .. } |
            CollectionMembers::InstanceBySources { template: n, ..} |
            CollectionMembers::Batch(n) |
            CollectionMembers::Component(n) =>
                n.name == component.name,
        }
    )
}

fn batch_state_var(
    component_slice: &ComponentStateSliceAllInstances,
    batch_name: Option<BatchName>,
    index: usize,
) -> Option<StateVarSlice> {

    let batch_def = component_slice.0.definition
        .unwrap_batch_def(&batch_name);
    (batch_def.member_state_var)(index, &component_slice.1)
}

fn nth_collection_member<'a>(
    core: &'a DoenetCore,
    component_instance: &ComponentInstance,
    index: usize,
) -> Option<ComponentGenerated<'a>> {

    let mut index = index;
    for c in core.collection_members.get(&component_instance.node.name).unwrap() {
        let (size, group_member);
        match c {
            CollectionMembers::Component(component) => {
                size = 1;
                group_member = Node(
                    component.instance_relative_to(&core. component_nodes, component_instance)
                );
            },
            CollectionMembers::Batch(component) => {
                let component_instance = component.instance_relative_to(&core. component_nodes, component_instance);
                size = resolve_batch_size(core, &component_instance, None);
                group_member = BatchMember(component_instance, None, index);
            },
            CollectionMembers::ComponentOnCondition { component, condition } => {
                let component_instance = component.instance_relative_to(&core. component_nodes, component_instance);
                let condition_variable = ComponentState(component_instance.clone(), condition.clone());
                let condition = resolve_state_variable(core, &condition_variable);
                size = (condition == Some(StateVarValue::Boolean(true))) as usize;
                group_member = Node(component_instance);
            },
            CollectionMembers::InstanceBySources { sources, template } => {
                size = collection_size(core, &sources.instance_relative_to(&core.component_nodes, component_instance));
                let mut map_new = template.relative_instance.relative_to(&component_instance.instance);
                map_new.push(index);
                group_member = Node(ComponentInstance {
                    node: core.component_nodes.get(&template.name).unwrap(),
                    instance: map_new,
                });
            },
        }
        if index > size {
            index -= size;
        } else {
            return Some(group_member);
        }
    }
    None
}

fn definition_as_replacement_child(component: &ComponentNode) -> &'static ComponentDefinition {
    component.definition.definition_as_replacement_children(&component.static_attributes)
        .unwrap_or(component.definition)
}



// ==== Relative Instance ====
// Find instances of dependencies relative to the component.

/// This holds "instructions" for how to get from one Instance to another.
/// - The integer shortens an Instance vector by that many.
/// - The vector is used to extend an Instance vector, specifying a component
/// inside further maps.
#[derive(PartialEq, Serialize, Eq, Clone, Debug, Default)]
struct RelativeInstance (usize, Vec<usize>);

#[derive(PartialEq, Serialize, Eq, Clone, Debug)]
pub struct ComponentRelative {
    name: ComponentName,
    relative_instance: RelativeInstance,
}

#[derive(PartialEq, Serialize, Eq, Clone, Debug)]
pub enum ComponentGeneratedRelative {
    NodeRel(ComponentRelative),
    BatchMemberRel(ComponentRelative, Option<BatchName>, usize),
}
use ComponentGeneratedRelative::*;

#[derive(PartialEq, Serialize, Eq, Clone, Debug)]
pub enum ComponentRefRelative  {
    Component(ComponentGeneratedRelative),
    CollectionMember(ComponentRelative, usize),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ComponentGroupRelative {
    Single(ComponentRefRelative),
    Collection(ComponentRelative),
    Batch(ComponentRelative),
}

#[derive(Debug, Clone)]
pub struct ComponentRefStateRelative (ComponentRefRelative, StateRef);

#[derive(Debug, Clone)]
pub struct ComponentRefStateSliceRelative (ComponentRefRelative, StateVarSlice);

#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub struct ComponentRefStateArrayRelative (ComponentRefRelative, StateVarName);

/// A StateVarSlice of every member of a group, and the instance is calculated relatively.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GroupStateSliceRelative (ComponentGroupRelative, StateVarSlice);

impl ComponentRelative {
    fn instance_relative_to<'a>(
        &self,
        component_nodes: &'a HashMap<ComponentName, ComponentNode>,
        component_instance: &ComponentInstance,
    ) -> ComponentInstance<'a> {
        let instance = self.relative_instance.relative_to(&component_instance.instance);
        ComponentInstance {
            node: component_nodes.get(&self.name).unwrap(),
            instance,
        }
    }
}

impl ComponentRefRelative {
    fn instance_relative_to<'a>(
        &self,
        component_nodes: &'a HashMap<ComponentName, ComponentNode>,
        component_instance: &ComponentInstance,
    ) -> ComponentRef<'a> {
        let component_relative = self.of_node_relative();
        let instance = component_relative.relative_instance.relative_to(&component_instance.instance);
        self.replace_instance(component_nodes, instance)
    }

    fn replace_instance<'a>(&self, component_nodes: &'a HashMap<ComponentName, ComponentNode>, instance: Instance) -> ComponentRef<'a> {
        match self {
            Self::Component(NodeRel(n)) =>
                ComponentRef::Component(Node(ComponentInstance {
                    node: component_nodes.get(&n.name).unwrap(),
                    instance,
                })),
            Self::Component(BatchMemberRel(n, c, i)) =>
                ComponentRef::Component(BatchMember(ComponentInstance {
                    node: component_nodes.get(&n.name).unwrap(),
                    instance,
                }, *c, *i)),
            Self::CollectionMember(n, i) =>
                ComponentRef::CollectionMember(ComponentInstance {
                    node: component_nodes.get(&n.name).unwrap(),
                    instance,
                }, *i),
        }
    }

    fn component_definition(&self, component_nodes: &HashMap<ComponentName, ComponentNode>)
        -> &'static ComponentDefinition {

        let node = component_nodes.get(&self.of_node_relative().name).unwrap();
        match self {
            Self::CollectionMember(_, _) =>
                (node.definition.unwrap_collection_def().member_definition)(&node.static_attributes),
            Self::Component(BatchMemberRel(_, n, _)) =>
                node.definition.unwrap_batch_def(n).member_definition,
            Self::Component(NodeRel(_)) => node.definition,
        }
    }

    fn of_node_relative(&self) -> &ComponentRelative {
        match self {
            Self::Component(node_or_batch) => node_or_batch.generated_by(),
            Self::CollectionMember(name, _) => name,
        }
    }
}

impl ComponentGeneratedRelative {
    fn generated_by(&self) -> &ComponentRelative {
        match self {
            Self::NodeRel(name) |
            Self::BatchMemberRel(name,_,_) => name,
        }
    }
}

impl ComponentGroupRelative {
    fn instance_relative_to<'a>(
        &self,
        component_nodes: &'a HashMap<ComponentName, ComponentNode>,
        component_instance: &'a ComponentInstance,
    ) -> ComponentGroup<'a> {
        let component_relative = self.of_node_relative(); 
        let instance = component_relative.relative_instance.relative_to(&component_instance.instance);
        self.replace_instance(component_nodes, instance)
    }

    fn replace_instance<'a>(&self, component_nodes: &'a HashMap<ComponentName, ComponentNode>, instance: Instance) -> ComponentGroup<'a> {
        match self {
            Self::Single(comp_ref) => ComponentGroup::Single(comp_ref.replace_instance(component_nodes, instance)),
            Self::Batch(n) => ComponentGroup::Batch(ComponentInstance {
                node: component_nodes.get(&n.name).unwrap(),
                instance,
            }),
            Self::Collection(n) => ComponentGroup::Collection(ComponentInstance {
                node: component_nodes.get(&n.name).unwrap(),
                instance,
            }),
        }
    }

    fn definition_member(&self, component_nodes: &HashMap<ComponentName, ComponentNode>)
        -> &'static ComponentDefinition {
        match self {
            Self::Single(comp_ref) => comp_ref.component_definition(component_nodes),
            Self::Batch(c) |
            Self::Collection(c) =>
                definition_as_replacement_child(component_nodes.get(&c.name).unwrap()),
        }
    }

    pub fn of_node_relative(&self) -> &ComponentRelative {
        match self {
            Self::Single(comp_ref) => comp_ref.of_node_relative(),
            Self::Collection(name) => name,
            Self::Batch(name) => name,
        }
    }
}

impl RelativeInstance {
    /// Convert RelativeInstance into Instance
    fn relative_to(&self, instance: &Instance) -> Instance {
        if self.is_empty() {
            return instance.clone();
        }

        let RelativeInstance(back, forward) = self;
        instance.clone().into_iter()
            .take(instance.len() - back)
            .chain(forward.clone().into_iter())
            .collect()
    }

    fn add_relative(self, other: Self) -> Self {
        let RelativeInstance(back, forward) = self;
        let RelativeInstance(other_back, other_forward) = other;
        let forward_len = forward.len() - other_back;
        if forward_len > 0 {
            let new_forward = forward.into_iter()
                .take(forward_len)
                .chain(other_forward.into_iter())
                .collect();
            RelativeInstance(back, new_forward)
        } else {
            let new_back = other_back - forward_len;
            RelativeInstance(new_back, other_forward)
        }
    }

    fn relative_to_inverse(&self, instance: &Instance) -> Instance {
        let take = instance.len() - self.1.len();
        instance.clone().into_iter().take(take).collect()
    }

    fn is_empty(&self) -> bool {
        self.0 == 0 && self.1.is_empty()
    }
}

fn calculate_relative_instance(
    components: &HashMap<ComponentName, MLComponent>,
    from: &MLComponent,
    to: &MLComponent,
    specified: Vec<usize>
) -> RelativeInstance {

    /// Duplicate of sources_that_instance_component but with MLComponents
    fn ml_sources_that_instance_component<'a>(
        components: &'a HashMap<ComponentName, MLComponent>,
        component: &'a MLComponent,
    ) -> Vec<&'a MLComponent> {
        let mut parents = ml_parent_chain(components, component).rev();
        let mut parent = parents.next().unwrap();
        let mut sources = vec![];
        for child in parents {
            if parent.definition.component_type == "map"
            && child.definition.component_type != "sources" {
                sources.push(parent);
            }
            parent = child;
        }
        sources
    }

    fn ml_parent_chain<'a>(
        component_nodes: &'a HashMap<ComponentName, MLComponent>,
        component: &'a MLComponent,
    ) -> impl DoubleEndedIterator<Item=&'a MLComponent> + Clone {
        let mut chain = vec![component];
        let mut loop_component = component;
        while loop_component.parent.is_some() {
            let parent_name = loop_component.parent.as_ref().unwrap();
            loop_component = component_nodes.get(parent_name).unwrap();
            chain.push(loop_component);
        }
        chain.into_iter()
    }

    let sources_from = ml_sources_that_instance_component(components, from);
    let sources_to = ml_sources_that_instance_component(components, to);
    let common_sources = std::cmp::min(sources_from.len(), sources_to.len());
    for i in 0..common_sources {
        assert_eq!(sources_from.get(i).unwrap().name, sources_to.get(i).unwrap().name)
    }
    let length_dff = sources_to.len() as isize - sources_from.len() as isize;
    if length_dff >= 0 {
        assert_eq!(length_dff as usize, specified.len(), "not enough maps specified");
    }

    if length_dff >= 0 {
        RelativeInstance(0, specified)
    } else {
        RelativeInstance((-length_dff) as usize, Vec::new())
    }
}


/// The number of maps a component is inside
fn component_inside_maps(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
) -> usize {
    sources_that_instance_component(component_nodes, component).len()
}

fn sources_that_instance_component<'a>(
    component_nodes: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> Vec<&'a ComponentNode> {
    let mut parents = parent_chain(component_nodes, component).rev();
    let mut parent = parents.next().unwrap();
    let mut sources = vec![];
    for child in parents {
        if parent.definition.component_type == "map"
        && child.definition.component_type != "sources" {
            let sources_child = get_children_of_type(component_nodes, parent, "sources", false)
                .next().unwrap();
            sources.push(sources_child);
        }
        parent = child;
    }
    sources
}

/// Vector of parents beginning with the component, then its parent, and so on until the root
fn parent_chain<'a>(
    component_nodes: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> impl DoubleEndedIterator<Item=&'a ComponentNode> + Clone {
    let mut chain = vec![component];
    let mut loop_component = component;
    while loop_component.parent.is_some() {
        let parent_name = loop_component.parent.as_ref().unwrap();
        loop_component = component_nodes.get(parent_name).unwrap();
        chain.push(loop_component);
    }
    chain.into_iter()
}



// ==== Error and warning checks during core creating ====

fn check_for_invalid_childen_component_profiles(component_nodes: &HashMap<ComponentName, ComponentNode>) -> Vec<DoenetMLWarning> {
    let mut doenet_ml_warnings = vec![];
    for (_, component) in component_nodes.iter() {
        if let ValidChildTypes::ValidProfiles(ref valid_profiles) = component.definition.valid_children_profiles {

            for child in component.children.iter().filter_map(|child| child.as_component()) {
                let child_comp = component_nodes.get(child).unwrap();
                let mut has_valid_profile = false;
                let child_member_def = child_comp.definition.definition_as_replacement_children(&child_comp.static_attributes).unwrap();
                for (child_profile, _) in child_member_def.component_profiles.iter() {
                    if valid_profiles.contains(child_profile) {
                        has_valid_profile = true;
                        break;
                    }
                }
                if matches!(child_member_def.replacement_components, Some(ReplacementComponents::Children)) {
                    has_valid_profile = true;
                }

                if has_valid_profile == false {
                    doenet_ml_warnings.push(DoenetMLWarning::InvalidChildType {
                        parent_comp_name: component.name.clone(),
                        child_comp_name: child_comp.name.clone(),
                        child_comp_type: child_member_def.component_type,
                    });
                }
            }
    
        }
    }
    doenet_ml_warnings
}

/// Do this before dependency generation so it doesn't crash
fn check_for_cyclical_copy_sources(component_nodes: &HashMap<ComponentName, ComponentNode>) -> Result<(), DoenetMLError> {
    // All the components that copy another component, along with the name of the component they copy
    let copy_comp_targets: Vec<(&ComponentNode, &ComponentRefRelative)> = component_nodes.iter().filter_map(|(_, c)|
        match c.copy_source {
            Some(CopySource::Component(ref component_ref_relative)) => Some((c, component_ref_relative)),
            _ => None,
        }
    ).collect();

    for (copy_component, _) in copy_comp_targets.iter() {
        if let Some(cyclic_error) = check_cyclic_copy_source_component(&component_nodes, copy_component) {
            return Err(cyclic_error);
        }
    }
    return Ok(())
}

fn check_cyclic_copy_source_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,

) -> Option<DoenetMLError> {

    let mut current_comp = component;
    let mut chain = vec![];
    while let Some(CopySource::Component(ref component_ref_relative)) = current_comp.copy_source {

        if chain.contains(&current_comp.name) {
            // Cyclical dependency
            chain.push(current_comp.name.clone());

            let start_index = chain.iter().enumerate().find_map(|(index, name)| {
                if name == &current_comp.name {
                    Some(index)
                } else {
                    None
                }
            }).unwrap();

            let (_, relevant_chain) = chain.split_at(start_index);

            return Some(DoenetMLError::CyclicalDependency {
                component_chain: Vec::from(relevant_chain),
                doenetml_range: RangeInDoenetML::None,
            });


        } else {

            chain.push(current_comp.name.clone());
            current_comp = components.get(&component_ref_relative.of_node_relative().name).unwrap();
        }
    }

    None
}

fn check_for_invalid_component_names(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_attributes: &HashMap<ComponentName, HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>>,
) -> Result<(), DoenetMLError> {

    for attributes_for_comp in component_attributes.values() {
        for attributes in attributes_for_comp.values() {
            for attribute_list in attributes.values() {
                for attr_object in attribute_list {

                    if let ObjectName::Component(comp_obj) = attr_object {
                        if !component_nodes.contains_key(comp_obj) {
                            // The component tried to copy a non-existent component.
                            return Err(DoenetMLError::ComponentDoesNotExist {
                                comp_name: comp_obj.to_owned(),
                                doenetml_range: RangeInDoenetML::None,
                            });
                        }
                    }
                }
            }
        }
    }
    Ok(())
}

fn check_for_cyclical_dependencies(dependencies: &HashMap<DependencyKey, Vec<Dependency>>) -> Result<(), DoenetMLError> {
   // Now that the dependency graph has been created, use it to check for cyclical dependencies
    // for all the components
    for (dep_key, _) in dependencies.iter() {
        let mut chain = vec![(dep_key.0.clone(), dep_key.1.clone())];
        let possible_error = check_for_cyclical_dependency_chain(&dependencies, &mut chain);

        if let Some(error) = possible_error {
            return Err(error);
        }
    }
    Ok(())
}

/// Check for cyclical dependencies, assuming that we have already traversed through the
/// given dependency chain. This function might become slow for larger documents with lots of copies
fn check_for_cyclical_dependency_chain(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    dependency_chain: &mut Vec<(ComponentName, StateVarSlice)>,
) -> Option<DoenetMLError> {

    // log_debug!("Dependency chain {:?}", dependency_chain);
    let last_link = dependency_chain.last().unwrap().clone();

    let my_dependencies = dependencies.iter().filter(|(dep_key, _)| {
        dep_key.0 == last_link.0 && dep_key.1 == last_link.1
    });

    for (_, dep_list) in my_dependencies {
        for dep in dep_list {
            let new_link = match dep {
                Dependency::StateVar { states } => {
                    Some((states.0.of_node_relative().name.clone(), states.1.clone()))
                },
                _ => None,
            };

            if let Some(new_link) = new_link {
                if dependency_chain.contains(&new_link) {
                    // Cyclical dependency!!

                    dependency_chain.push(new_link.clone());
                    log_debug!("Cyclical dependency through {:?} with duplicate {:?}", dependency_chain, new_link);

                    let start_index = dependency_chain.iter().enumerate().find_map(|(index, item)| {
                        if item == &new_link {
                            Some(index)
                        } else {
                            None
                        }
                    }).unwrap();

                    let (_, relevant_chain) = dependency_chain.split_at(start_index);
                    let mut component_chain = vec![];
                    for link in relevant_chain.into_iter() {
                        if component_chain.is_empty() || component_chain.last().unwrap() != &link.0 {
                            component_chain.push(link.0.clone());
                        }
                    }

                    return Some(DoenetMLError::CyclicalDependency {
                        component_chain,
                        doenetml_range: RangeInDoenetML::None,
                    });

                } else {
                    dependency_chain.push(new_link);
                    let possible_error = check_for_cyclical_dependency_chain(dependencies, dependency_chain);
                    dependency_chain.pop();

                    if let Some(error) = possible_error {
                        return Some(error);
                    }
                }
            }
        }
    }

    None
}



fn convert_float_to_usize(f: f64) -> Option<usize> {
    let my_int = f as i64;
    if my_int as f64 == f {
        // no loss of precision
        usize::try_from(my_int).ok()
    } else {
        None
    }
}

fn indices_for_size(size: usize) -> std::ops::Range<usize> {
    1..size+1
}
